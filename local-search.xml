<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Windows下蓝牙音箱无法调节音量的解决方案</title>
    <link href="/2021/01/18/Windows%E4%B8%8B%E8%93%9D%E7%89%99%E9%9F%B3%E7%AE%B1%E6%97%A0%E6%B3%95%E8%B0%83%E8%8A%82%E9%9F%B3%E9%87%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2021/01/18/Windows%E4%B8%8B%E8%93%9D%E7%89%99%E9%9F%B3%E7%AE%B1%E6%97%A0%E6%B3%95%E8%B0%83%E8%8A%82%E9%9F%B3%E9%87%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注: 本文引用至 <a href="https://www.simaek.com/archives/17/" target="_blank" rel="noopener">https://www.simaek.com/archives/17/</a></p></blockquote><p>Windows1803版本后默认启用了蓝牙绝对音量，导致连接一些蓝牙音箱没有办法通过电脑调节音量大小，只有0和1-100的区别，0静音，1-100都是同一个音量</p><p>微软没有给出关闭这个特性的选项，所以只能通过修改注册表的方式来实现</p><p>打开注册表编辑器，展开路径 <code>\HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Bluetooth\Audio\AVRCP\CT</code><br>，找到 <code>DisableAbsoluteVolume</code>，值修改为1，如果没有，右键新建DWORD32位值，命名为 <code>DisableAbsoluteVolume</code>，值为1。</p><p>如果没有生效，重启一下电脑，再试试看，应该就能使用电脑控制蓝牙音箱的音量了。</p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows10</tag>
      
      <tag>Bluetooth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何彻底删除Windows10上的外挂蓝牙设备</title>
    <link href="/2020/12/20/%E5%A6%82%E4%BD%95%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4Windows10%E4%B8%8A%E7%9A%84%E5%A4%96%E6%8C%82%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87/"/>
    <url>/2020/12/20/%E5%A6%82%E4%BD%95%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4Windows10%E4%B8%8A%E7%9A%84%E5%A4%96%E6%8C%82%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就在方才，我发现我的蓝牙耳机突然连接不上了，按照一般方法来说，都是<strong>删除设备之后再重新连接</strong>，可是Windows它竟然无法删除设备！！  </p><p>于是我就在 <em>tenforums</em> 上找到了一篇关于如何彻底删除蓝牙设备的文章</p><blockquote><p><a href="https://www.tenforums.com/drivers-hardware/22049-how-completely-remove-bluetooth-device-win-10-a.html#post1540911" target="_blank" rel="noopener">https://www.tenforums.com/drivers-hardware/22049-how-completely-remove-bluetooth-device-win-10-a.html#post1540911</a><br><img src="/img/bluetooth.png" srcset="/img/loading.gif" alt="链接图片"></p></blockquote><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol><li>下载 <a href="http://bluetoothinstaller.com/bluetooth-command-line-tools/" target="_blank" rel="noopener">蓝牙管理工具</a>, 并完成安装。 <a href="http://bluetoothinstaller.com/bluetooth-command-line-tools/BluetoothCLTools-1.2.0.56.exe" target="_blank" rel="noopener">找不到 Download 可以点我</a></li><li>打开 <strong>Powershell/Cmd</strong>，命令行输入 <code>btpair -u</code> 并回车执行</li><li>等待，会发现<strong>已配对的蓝牙设备</strong> 终于 <strong><em>成功 彻底</em></strong> 被删除了</li></ol><p><img src="/img/nb2.png" srcset="/img/loading.gif" alt="NB2"></p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows10</tag>
      
      <tag>Bluetooth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在Bukkit服务器上读取玩家的NBT</title>
    <link href="/2020/10/17/%E5%A6%82%E4%BD%95%E5%9C%A8Bukkit%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%AF%BB%E5%8F%96%E7%8E%A9%E5%AE%B6%E7%9A%84NBT/"/>
    <url>/2020/10/17/%E5%A6%82%E4%BD%95%E5%9C%A8Bukkit%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%AF%BB%E5%8F%96%E7%8E%A9%E5%AE%B6%E7%9A%84NBT/</url>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>导读</li><li>如何读取</li><li>读取离线玩家的背包</li><li>将修改后的NBT保存回playerdata</li></ul><h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>本教程需要玩家拥有关于 <strong>NMS</strong> 里的 NBT 的相关知识</p><blockquote><p>本教程使用 <strong>Paper 1.15.2</strong> 的版本作为演示</p></blockquote><h1 id="如何读取"><a href="#如何读取" class="headerlink" title="如何读取"></a>如何读取</h1><p>其实这个功能在古老的 1.12 之前的版本就已经有了, 只不过一直懒得去做这方面的东西<br>在我在写这一篇文章之前我通过反编译知道, 早在 1.7.10 就已经拥有了这个方法, 所以本方法适用于目前的所有办法, 并且该方法应该不会经常改动  </p><p>总所周知的是, 在 <em>MinecraftServer</em> 中, 所有玩家的数据都会被保存在 <code>world\playerdata</code> 里面, 并且以 <strong>玩家uuid.dat</strong> 的方式来命名<br>所以我们只需要读取这些 <em>dat</em> 文件就可以得到相对应的玩家数据</p><hr><p>首先我们需要得到玩家对应的 <em>dat</em> 文件 </p><pre><code class="hljs java"><span class="hljs-comment">// playerdata</span>File playerDataFolder = <span class="hljs-keyword">new</span> File(getDataFolder().getParentFile().getParentFile(), <span class="hljs-string">"world\\playerdata\\"</span>);<span class="hljs-comment">// uuid</span>String uuid = player.getUniqueId().toString();<span class="hljs-comment">// 玩家的nbt数据文件</span>File playerDat = <span class="hljs-keyword">new</span> File(playerDataFolder, uuid + <span class="hljs-string">".dat"</span>);</code></pre><p>之后我们将其丢入 FileInputStream 当中</p><pre><code class="hljs java">FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(playerDat);</code></pre><p>开始读取!</p><pre><code class="hljs java">NBTTagCompound nbt = NBTCompressedStreamTools.a(inputStream);</code></pre><p>输出 <em>nbt</em> 可以得到以下的内容</p><details>  <summary>点我查看</summary>  <pre><blockcode>      {    seenCredits: 0b,    DeathTime: 0 s,    AbsorptionAmount: 0.0 f,    SpawnWorld: "world",    Bukkit.updateLevel: 2,    foodTickTimer: 0,    UUIDLeast: -7709988740583578109 L,    recipeBook: {        isGuiOpen: 0b,        recipes: ["minecraft:chest", "minecraft:charcoal", "minecraft:dark_oak_button", "minecraft:stone_hoe", "minecraft:item_frame", "minecraft:green_concrete_powder", "minecraft:lever", "minecraft:pumpkin_pie", "minecraft:stone_button", "minecraft:granite_slab_from_granite_stonecutting", "minecraft:stone_pickaxe", "minecraft:stonecutter", "minecraft:dark_oak_fence", "minecraft:skull_banner_pattern", "minecraft:granite_stairs_from_granite_stonecutting", "minecraft:iron_door", "minecraft:shield", "minecraft:polished_granite", "minecraft:iron_nugget", "minecraft:sandstone", "minecraft:yellow_concrete_powder", "minecraft:cooked_porkchop_from_campfire_cooking", "minecraft:dark_oak_trapdoor", "minecraft:red_concrete_powder", "minecraft:cobblestone_stairs_from_cobblestone_stonecutting", "minecraft:iron_shovel", "minecraft:polished_diorite_slab", "minecraft:jack_o_lantern", "minecraft:hopper", "minecraft:black_dye_from_wither_rose", "minecraft:glass", "minecraft:stone_stairs_from_stone_stonecutting", "minecraft:crafting_table", "minecraft:stone_stairs", "minecraft:lantern", "minecraft:iron_leggings", "minecraft:cobblestone_wall", "minecraft:blue_concrete_powder", "minecraft:polished_diorite_slab_from_diorite_stonecutting", "minecraft:white_concrete_powder", "minecraft:stone_slab_from_stone_stonecutting", "minecraft:iron_bars", "minecraft:iron_boots", "minecraft:iron_trapdoor", "minecraft:gray_concrete_powder", "minecraft:dark_oak_sign", "minecraft:granite_slab", "minecraft:iron_helmet", "minecraft:stone_brick_slab_from_stone_stonecutting", "minecraft:stick", "minecraft:light_blue_concrete_powder", "minecraft:leather_chestplate", "minecraft:light_gray_concrete_powder", "minecraft:granite_wall_from_granite_stonecutting", "minecraft:leather_boots", "minecraft:anvil", "minecraft:dark_oak_stairs", "minecraft:furnace", "minecraft:iron_block", "minecraft:granite_stairs", "minecraft:stone_slab", "minecraft:dark_oak_door", "minecraft:cooked_porkchop", "minecraft:lime_concrete_powder", "minecraft:leather_leggings", "minecraft:dark_oak_pressure_plate", "minecraft:cooked_porkchop_from_smoking", "minecraft:stone_axe", "minecraft:leather_helmet", "minecraft:beacon", "minecraft:oak_wood", "minecraft:barrel", "minecraft:stone", "minecraft:polished_diorite_stairs_from_polished_diorite_stonecutting", "minecraft:polished_granite_from_granite_stonecutting", "minecraft:oak_planks", "minecraft:bone_meal", "minecraft:stone_brick_stairs_from_stone_stonecutting", "minecraft:polished_diorite_stairs_from_diorite_stonecutting", "minecraft:iron_sword", "minecraft:crossbow", "minecraft:chiseled_stone_bricks_stone_from_stonecutting", "minecraft:red_sandstone", "minecraft:iron_chestplate", "minecraft:pumpkin_seeds", "minecraft:stone_bricks", "minecraft:iron_pickaxe", "minecraft:smithing_table", "minecraft:black_concrete_powder", "minecraft:polished_granite_stairs_from_granite_stonecutting", "minecraft:purple_concrete_powder", "minecraft:smooth_stone", "minecraft:pink_concrete_powder", "minecraft:heavy_weighted_pressure_plate", "minecraft:stone_shovel", "minecraft:cobblestone_stairs", "minecraft:cobblestone_wall_from_cobblestone_stonecutting", "minecraft:leather_horse_armor", "minecraft:brown_concrete_powder", "minecraft:granite_wall", "minecraft:orange_concrete_powder", "minecraft:polished_diorite_stairs", "minecraft:magenta_concrete_powder", "minecraft:shears", "minecraft:stone_pressure_plate", "minecraft:polished_granite_slab_from_granite_stonecutting", "minecraft:stone_sword", "minecraft:dark_oak_slab", "minecraft:iron_axe", "minecraft:cobblestone_slab", "minecraft:iron_hoe", "minecraft:iron_ingot_from_iron_block", "minecraft:cyan_concrete_powder", "minecraft:minecart", "minecraft:coarse_dirt", "minecraft:dark_oak_fence_gate", "minecraft:stone_brick_walls_from_stone_stonecutting", "minecraft:bucket", "minecraft:cobblestone_slab_from_cobblestone_stonecutting", "minecraft:stone_bricks_from_stone_stonecutting", "minecraft:polished_diorite_slab_from_polished_diorite_stonecutting"],        toBeDisplayed: ["minecraft:chest", "minecraft:charcoal", "minecraft:dark_oak_button", "minecraft:stone_hoe", "minecraft:item_frame", "minecraft:green_concrete_powder", "minecraft:lever", "minecraft:pumpkin_pie", "minecraft:stone_button", "minecraft:granite_slab_from_granite_stonecutting", "minecraft:stone_pickaxe", "minecraft:stonecutter", "minecraft:dark_oak_fence", "minecraft:skull_banner_pattern", "minecraft:granite_stairs_from_granite_stonecutting", "minecraft:iron_door", "minecraft:shield", "minecraft:polished_granite", "minecraft:iron_nugget", "minecraft:sandstone", "minecraft:yellow_concrete_powder", "minecraft:cooked_porkchop_from_campfire_cooking", "minecraft:dark_oak_trapdoor", "minecraft:red_concrete_powder", "minecraft:cobblestone_stairs_from_cobblestone_stonecutting", "minecraft:iron_shovel", "minecraft:polished_diorite_slab", "minecraft:jack_o_lantern", "minecraft:hopper", "minecraft:black_dye_from_wither_rose", "minecraft:glass", "minecraft:stone_stairs_from_stone_stonecutting", "minecraft:crafting_table", "minecraft:stone_stairs", "minecraft:lantern", "minecraft:iron_leggings", "minecraft:cobblestone_wall", "minecraft:blue_concrete_powder", "minecraft:polished_diorite_slab_from_diorite_stonecutting", "minecraft:white_concrete_powder", "minecraft:stone_slab_from_stone_stonecutting", "minecraft:iron_bars", "minecraft:iron_boots", "minecraft:iron_trapdoor", "minecraft:gray_concrete_powder", "minecraft:dark_oak_sign", "minecraft:granite_slab", "minecraft:iron_helmet", "minecraft:stone_brick_slab_from_stone_stonecutting", "minecraft:stick", "minecraft:light_blue_concrete_powder", "minecraft:leather_chestplate", "minecraft:light_gray_concrete_powder", "minecraft:granite_wall_from_granite_stonecutting", "minecraft:leather_boots", "minecraft:anvil", "minecraft:dark_oak_stairs", "minecraft:furnace", "minecraft:iron_block", "minecraft:granite_stairs", "minecraft:stone_slab", "minecraft:dark_oak_door", "minecraft:cooked_porkchop", "minecraft:lime_concrete_powder", "minecraft:leather_leggings", "minecraft:dark_oak_pressure_plate", "minecraft:cooked_porkchop_from_smoking", "minecraft:stone_axe", "minecraft:leather_helmet", "minecraft:beacon", "minecraft:oak_wood", "minecraft:barrel", "minecraft:stone", "minecraft:polished_diorite_stairs_from_polished_diorite_stonecutting", "minecraft:polished_granite_from_granite_stonecutting", "minecraft:oak_planks", "minecraft:bone_meal", "minecraft:stone_brick_stairs_from_stone_stonecutting", "minecraft:polished_diorite_stairs_from_diorite_stonecutting", "minecraft:iron_sword", "minecraft:crossbow", "minecraft:chiseled_stone_bricks_stone_from_stonecutting", "minecraft:red_sandstone", "minecraft:iron_chestplate", "minecraft:pumpkin_seeds", "minecraft:stone_bricks", "minecraft:iron_pickaxe", "minecraft:smithing_table", "minecraft:black_concrete_powder", "minecraft:polished_granite_stairs_from_granite_stonecutting", "minecraft:purple_concrete_powder", "minecraft:smooth_stone", "minecraft:pink_concrete_powder", "minecraft:heavy_weighted_pressure_plate", "minecraft:stone_shovel", "minecraft:cobblestone_stairs", "minecraft:cobblestone_wall_from_cobblestone_stonecutting", "minecraft:leather_horse_armor", "minecraft:brown_concrete_powder", "minecraft:granite_wall", "minecraft:orange_concrete_powder", "minecraft:polished_diorite_stairs", "minecraft:magenta_concrete_powder", "minecraft:shears", "minecraft:stone_pressure_plate", "minecraft:polished_granite_slab_from_granite_stonecutting", "minecraft:stone_sword", "minecraft:dark_oak_slab", "minecraft:iron_axe", "minecraft:cobblestone_slab", "minecraft:iron_hoe", "minecraft:iron_ingot_from_iron_block", "minecraft:cyan_concrete_powder", "minecraft:minecart", "minecraft:coarse_dirt", "minecraft:dark_oak_fence_gate", "minecraft:stone_brick_walls_from_stone_stonecutting", "minecraft:bucket", "minecraft:cobblestone_slab_from_cobblestone_stonecutting", "minecraft:stone_bricks_from_stone_stonecutting", "minecraft:polished_diorite_slab_from_polished_diorite_stonecutting"],        isFurnaceGuiOpen: 0b,        isFurnaceFilteringCraftable: 0b,        isFilteringCraftable: 0b    },    OnGround: 1 b,    XpTotal: 60,    Attributes: [{        Name: "generic.maxHealth",        Base: 20.0 d    }, {        Name: "generic.knockbackResistance",        Base: 0.0 d    }, {        Name: "generic.movementSpeed",        Base: 0.10000000149011612 d    }, {        Name: "generic.armor",        Base: 0.0 d    }, {        Name: "generic.armorToughness",        Base: 0.0 d    }, {        Name: "generic.attackDamage",        Base: 1.0 d    }, {        Name: "generic.attackSpeed",        Base: 4.0 d    }, {        Name: "generic.luck",        Base: 0.0 d    }],    playerGameType: 1,    SelectedItemSlot: 4,    Invulnerable: 0b,    Brain: {        memories: {}    },    bukkit: {        newTotalExp: 0,        newLevel: 0,        newExp: 0,        keepLevel: 0b,        expToDrop: 0,        lastPlayed: 1602948728077 L,        firstPlayed: 1598409215186 L,        lastKnownName: "Zoyn"    },    Dimension: 0,    Paper.Origin: [-99.5 d, 70.0 d, -51.5 d],    Score: 60,    UUIDMost: -7592284996227679300 L,    abilities: {        walkSpeed: 0.1 f,        flySpeed: 0.05 f,        flying: 0b,        instabuild: 1 b,        invulnerable: 1 b,        mayfly: 1 b,        mayBuild: 1 b    },    Rotation: [-325.99268 f, 24.149998 f],    HurtByTimestamp: 0,    foodSaturationLevel: 6.8 f,    WorldUUIDMost: -3093603006290312122 L,    Motion: [0.0 d, -0.0784000015258789 d, 0.0 d],    Air: 300 s,    WorldUUIDLeast: -6703577456958716675 L,    XpSeed: -903103853,    DataVersion: 2230,    Inventory: [{        Slot: 0b,        id: "minecraft:stone",        Count: 64 b    }, {        Slot: 1 b,        id: "minecraft:diamond_sword",        Count: 1 b,        tag: {            Damage: 0        }    }, {        Slot: 2 b,        id: "minecraft:bone",        Count: 1 b    }, {        Slot: 3 b,        id: "minecraft:stone",        Count: 64 b    }, {        Slot: 4 b,        id: "minecraft:bee_nest",        Count: 1 b    }, {        Slot: 5 b,        id: "minecraft:stone",        Count: 1 b    }],    XpLevel: 5,    Spigot.ticksLived: 705164,    FallDistance: 0.0 f,    foodLevel: 20,    SleepTimer: 0 s,    EnderItems: [],    XpP: 0.2941176 f,    Paper: {        LastLogin: 1602944296604 L,        LastSeen: 1602948728077 L    },    FallFlying: 0b,    HurtTime: 0 s,    Health: 20.0 f,    Pos: [200.30000001192093 d, 83.0 d, -296.69999998807907 d],    Fire: -20 s,    PortalCooldown: 0,    foodExhaustionLevel: 0.06499999 f,    Paper.SpawnReason: "DEFAULT"}  </blockcode></pre></details><hr><p>完整代码</p><pre><code class="hljs java">File playerDataFolder = <span class="hljs-keyword">new</span> File(getDataFolder().getParentFile().getParentFile(), <span class="hljs-string">"world\\playerdata\\"</span>);File playerDat = <span class="hljs-keyword">new</span> File(playerDataFolder, player.getUniqueId().toString() + <span class="hljs-string">".dat"</span>);<span class="hljs-keyword">try</span> &#123;    FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(playerDat);    NBTTagCompound nbt = NBTCompressedStreamTools.a(inputStream);    NBTTagList tagList = nbt.getList(<span class="hljs-string">"Inventory"</span>, <span class="hljs-number">10</span>);    System.out.println(tagList);&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    e.printStackTrace();&#125;</code></pre><p>所以其实我们看到, 真正的读取都是利用了 <em>NBTCompressedStreamTools</em> 这个已经在 NMS 写好的工具类<br>而我们只是利用轮子的人</p><h1 id="读取离线玩家的背包"><a href="#读取离线玩家的背包" class="headerlink" title="读取离线玩家的背包"></a>读取离线玩家的背包</h1><p>那么我们可以通过上面的 <strong>NBT样本</strong> 看到了其实里面保存有玩家的物品, 而这样我们可以利用这个NBT数据将其读取出来<br>看下面的代码</p><pre><code class="hljs java">File playerDataFolder = <span class="hljs-keyword">new</span> File(getDataFolder().getParentFile().getParentFile(), <span class="hljs-string">"world\\playerdata\\"</span>);File playerDat = <span class="hljs-keyword">new</span> File(playerDataFolder, player.getUniqueId().toString() + <span class="hljs-string">".dat"</span>);<span class="hljs-keyword">try</span> &#123;    FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(playerDat);    NBTTagCompound nbt = NBTCompressedStreamTools.a(inputStream);<span class="hljs-comment">// 得到 玩家NBT里的 Inventory</span>    NBTTagList tagList = nbt.getList(<span class="hljs-string">"Inventory"</span>, <span class="hljs-number">10</span>);    System.out.println(tagList);<span class="hljs-comment">// 转为Bukkit进行读取</span>    List&lt;org.bukkit.inventory.ItemStack&gt; itemStackList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tagList.size(); i++) &#123;        NBTTagCompound compound = (NBTTagCompound) tagList.get(i);<span class="hljs-comment">// 这里的ItemStack其实是NMS下的ItemStack!</span>        ItemStack nmsItem = ItemStack.a(compound);        itemStackList.add(nmsItem.getBukkitStack());    &#125;    Inventory inventory = Bukkit.createInventory(<span class="hljs-keyword">null</span>, <span class="hljs-number">54</span>);    inventory.addItem(itemStackList.toArray(<span class="hljs-keyword">new</span> org.bukkit.inventory.ItemStack[<span class="hljs-number">0</span>]));    player.openInventory(inventory);&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    e.printStackTrace();&#125;</code></pre><p>控制台输出:</p><pre><code class="hljs dts">[&#123;<span class="hljs-symbol">Slot:</span> <span class="hljs-number">0</span>b,<span class="hljs-symbol">id:</span> <span class="hljs-string">"minecraft:stone"</span>,<span class="hljs-symbol">Count:</span> <span class="hljs-number">64</span>b&#125;, &#123;<span class="hljs-symbol">Slot:</span> <span class="hljs-number">1</span>b,<span class="hljs-symbol">id:</span> <span class="hljs-string">"minecraft:diamond_sword"</span>,<span class="hljs-symbol">Count:</span> <span class="hljs-number">1</span>b,<span class="hljs-symbol">tag:</span> &#123;<span class="hljs-symbol">Damage:</span> <span class="hljs-number">0</span>&#125;&#125;, &#123;<span class="hljs-symbol">Slot:</span> <span class="hljs-number">4</span>b,<span class="hljs-symbol">id:</span> <span class="hljs-string">"minecraft:bee_nest"</span>,<span class="hljs-symbol">Count:</span> <span class="hljs-number">1</span>b&#125;, &#123;<span class="hljs-symbol">Slot:</span> <span class="hljs-number">5</span>b,<span class="hljs-symbol">id:</span> <span class="hljs-string">"minecraft:stone"</span>,<span class="hljs-symbol">Count:</span> <span class="hljs-number">1</span>b&#125;]</code></pre><p>游戏内效果:<br><img src="/img/playernbt.png" srcset="/img/loading.gif" alt="游戏内效果"></p><h1 id="将修改后的NBT保存回playerdata"><a href="#将修改后的NBT保存回playerdata" class="headerlink" title="将修改后的NBT保存回playerdata"></a>将修改后的NBT保存回playerdata</h1><p>具体请看这里 <em>net.minecraft.server.v1_xx_Rx.WorldNBTStorage</em><br>具体代码:<br><img src="/img/nbtsave.png" srcset="/img/loading.gif" alt="保存的代码"></p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
      <tag>NMS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些我收集的常用资源网站</title>
    <link href="/2020/09/16/%E4%B8%80%E4%BA%9B%E6%88%91%E6%94%B6%E9%9B%86%E7%9A%84%E5%B8%B8%E7%94%A8%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99/"/>
    <url>/2020/09/16/%E4%B8%80%E4%BA%9B%E6%88%91%E6%94%B6%E9%9B%86%E7%9A%84%E5%B8%B8%E7%94%A8%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h1><ul><li>MH工具库<blockquote><p><a href="http://www.mh-studio.cn/down/index.html" target="_blank" rel="noopener">http://www.mh-studio.cn/down/index.html</a></p></blockquote></li><li>MH资源库<blockquote><p><a href="https://mh-studio.cn/down/resource.html" target="_blank" rel="noopener">https://mh-studio.cn/down/resource.html</a></p></blockquote></li><li>兔二工具箱<blockquote><p><a href="https://tool2.cn/" target="_blank" rel="noopener">https://tool2.cn/</a></p></blockquote></li><li>翻应用<blockquote><p><a href="https://www.iapps.me/" target="_blank" rel="noopener">https://www.iapps.me/</a></p></blockquote></li></ul><h1 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h1><ul><li>中国政府网-数据<blockquote><p><a href="http://www.gov.cn/shuju/index.htm" target="_blank" rel="noopener">http://www.gov.cn/shuju/index.htm</a><br><a href="http://www.gov.cn/shuju/2017sjcs/sjxqpage.htm" target="_blank" rel="noopener">http://www.gov.cn/shuju/2017sjcs/sjxqpage.htm</a></p></blockquote></li><li>国家统计局<blockquote><p><a href="http://www.stats.gov.cn/" target="_blank" rel="noopener">http://www.stats.gov.cn/</a></p></blockquote></li><li>中国各地区统计年鉴<blockquote><p><a href="https://www.yearbookchina.com/" target="_blank" rel="noopener">https://www.yearbookchina.com/</a></p></blockquote></li><li>广西统计<blockquote><p><a href="http://tjsj.gxtj.gov.cn:18090/pub/index.htm" target="_blank" rel="noopener">http://tjsj.gxtj.gov.cn:18090/pub/index.htm</a></p></blockquote></li><li>广西地情资料库<blockquote><p><a href="http://www.gxdfz.org.cn/gdtz/" target="_blank" rel="noopener">http://www.gxdfz.org.cn/gdtz/</a></p></blockquote></li><li>联合国数据库<blockquote><p><a href="https://www.un.org/zh/databases/index.html" target="_blank" rel="noopener">https://www.un.org/zh/databases/index.html</a></p></blockquote></li><li>TradingEconomics(各国宏观数据)<blockquote><p><a href="https://zh.tradingeconomics.com/" target="_blank" rel="noopener">https://zh.tradingeconomics.com/</a></p></blockquote></li></ul><h1 id="学术类"><a href="#学术类" class="headerlink" title="学术类"></a>学术类</h1><ul><li>中国知网<blockquote><p><a href="https://www.cnki.net/" target="_blank" rel="noopener">https://www.cnki.net/</a></p></blockquote></li><li>爱学术<blockquote><p><a href="https://www.ixueshu.com/" target="_blank" rel="noopener">https://www.ixueshu.com/</a></p></blockquote></li><li>百度学术<blockquote><p><a href="https://xueshu.baidu.com/" target="_blank" rel="noopener">https://xueshu.baidu.com/</a></p></blockquote></li><li>人工智能的百度<blockquote><p><a href="https://www.wolframalpha.com/" target="_blank" rel="noopener">https://www.wolframalpha.com/</a></p></blockquote></li><li>谷粉学术<blockquote><p><a href="https://gfsoso.99lb.net/" target="_blank" rel="noopener">https://gfsoso.99lb.net/</a></p></blockquote></li><li>谷歌学术(需翻墙)<blockquote><p><a href="https://scholar.google.com/" target="_blank" rel="noopener">https://scholar.google.com/</a></p></blockquote></li><li>谷歌学术(镜像站)<blockquote><p><a href="https://ac.scmor.com/" target="_blank" rel="noopener">https://ac.scmor.com/</a></p></blockquote></li></ul><h1 id="作图-工作类"><a href="#作图-工作类" class="headerlink" title="作图/工作类"></a>作图/工作类</h1><ul><li>来画视频(短视频动画创作)<blockquote><p><a href="https://www.laihua.com" target="_blank" rel="noopener">https://www.laihua.com</a></p></blockquote></li><li>Arkie(海报制作工具)]<blockquote><p><a href="https://www.arkie.cn" target="_blank" rel="noopener">https://www.arkie.cn</a></p></blockquote></li><li>优品PPT<blockquote><p><a href="http://www.ypppt.com" target="_blank" rel="noopener">http://www.ypppt.com</a></p></blockquote></li><li>比格PPT<blockquote><p><a href="http://www.tretars.com" target="_blank" rel="noopener">http://www.tretars.com</a></p></blockquote></li><li>图片压缩(腾讯)<blockquote><p><a href="https://zhitu.isux.us" target="_blank" rel="noopener">https://zhitu.isux.us</a></p></blockquote></li><li>字体<blockquote><p><a href="https://www.fontspace.com/" target="_blank" rel="noopener">https://www.fontspace.com/</a></p></blockquote></li><li>中国传统颜色<blockquote><p><a href="http://zhongguose.com/#hehuanhong" target="_blank" rel="noopener">http://zhongguose.com/#hehuanhong</a></p></blockquote></li><li>新CG儿-AE模板<blockquote><p><a href="https://www.newcger.com/" target="_blank" rel="noopener">https://www.newcger.com/</a></p></blockquote></li></ul><h1 id="电子书-与-PDF"><a href="#电子书-与-PDF" class="headerlink" title="电子书 与 PDF"></a>电子书 与 PDF</h1><ul><li>PDF文件转换器 - 可转Word Excel PPT<blockquote><p><a href="https://smallpdf.com/cn/pdf-converter" target="_blank" rel="noopener">https://smallpdf.com/cn/pdf-converter</a></p></blockquote></li><li>电子书转换器<ul><li>Epubee<blockquote><p><a href="http://cn.epubee.com/" target="_blank" rel="noopener">http://cn.epubee.com/</a></p></blockquote></li><li>Convertio<blockquote><p><a href="https://convertio.co/zh/ebook-converter/" target="_blank" rel="noopener">https://convertio.co/zh/ebook-converter/</a> </p></blockquote></li><li>EPUB to PDF - Online Converter<blockquote><p><a href="https://www.onlineconverter.com/epub-to-pdf" target="_blank" rel="noopener">https://www.onlineconverter.com/epub-to-pdf</a> </p></blockquote></li></ul></li></ul><h1 id="电影与视频解析资源"><a href="#电影与视频解析资源" class="headerlink" title="电影与视频解析资源"></a>电影与视频解析资源</h1><ul><li>无水印片源(片源网)<blockquote><p><a href="http://pianyuan.la/" target="_blank" rel="noopener">http://pianyuan.la/</a></p></blockquote></li><li>电影港<blockquote><p><a href="http://www.dygangs.com" target="_blank" rel="noopener">http://www.dygangs.com</a><br><a href="http://www.dygang.com" target="_blank" rel="noopener">http://www.dygang.com</a></p></blockquote></li><li>在线视频解析<blockquote><p><a href="http://www.iiilab.com/m/article/11" target="_blank" rel="noopener">http://www.iiilab.com/m/article/11</a></p></blockquote></li></ul><h1 id="资源查找"><a href="#资源查找" class="headerlink" title="资源查找"></a>资源查找</h1><ul><li>磁力链接搜索引擎<blockquote><p><a href="https://fwonggh.github.io/Bthub/" target="_blank" rel="noopener">https://fwonggh.github.io/Bthub/</a></p></blockquote></li></ul><h1 id="其他未归类资源"><a href="#其他未归类资源" class="headerlink" title="其他未归类资源"></a>其他未归类资源</h1><ul><li>QQ/网易云等音乐解锁<blockquote><p><a href="https://github.com/ix64/unlock-music" target="_blank" rel="noopener">https://github.com/ix64/unlock-music</a></p></blockquote></li><li>AdobeZii激活工具<blockquote><p><a href="https://www.macbl.com/app/graphics-design/adobe-zii" target="_blank" rel="noopener">https://www.macbl.com/app/graphics-design/adobe-zii</a></p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>资源</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三观？其实是一个人成长环境的缩影</title>
    <link href="/2020/09/03/%E4%B8%89%E8%A7%82%EF%BC%9F%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF%E7%8E%AF%E5%A2%83%E7%9A%84%E7%BC%A9%E5%BD%B1/"/>
    <url>/2020/09/03/%E4%B8%89%E8%A7%82%EF%BC%9F%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF%E7%8E%AF%E5%A2%83%E7%9A%84%E7%BC%A9%E5%BD%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>人永远是一种复杂的生物</strong></p><p>我往往会去思考在<strong>人类社会</strong>刚刚建设的初期</p><p>当时的人类都是以什么样的方式来统治社会</p><p>直到我们现在，我们也依然生活在我们所创造的这个社会当中</p><p>我们不能去忽视我们的社会，而<strong>单单的去观察人本身</strong></p><p>在当下，我们往往会在一些文案当中看到或听到这个词</p><p><strong>阶级</strong></p><p>阶级这个概念早在我们中国先秦时期的宗法制就已经体现出来</p><p>纵观人类历史，我们可以利用阶级来思考一些问题</p><p>通过阶级这一概念的引入，我们也就不难发现在某些事中为何会引起冲突</p><p>而在我看来 阶级 便是一个影响人的三观的重要因素</p><p>所以我会在下方列举相关在我看来是会影响到人的三观的因素</p><h1 id="三观正"><a href="#三观正" class="headerlink" title="三观正"></a>三观正</h1><p>什么是三观正？</p><p>我想答案在<strong>每一位读者心中</strong></p><p>三观正，其实就是三观和我一样的赞美</p><p>为什么这么说，首先先思考一个问题，<strong>什么是正？</strong></p><p>我在许许多多的影视作品中发现</p><p>往往是两方在对立的时候，就会出现<strong>“正派”</strong>与<strong>“邪派”</strong></p><p>在影视作品中通常会通过一些艺术手法扩大了这一方面的矛盾</p><p>例如：你是某团团长，而作为军人</p><p>你所需要做的就是服从上级命令，一切行动听指挥</p><p>而当我们真正代入到影视作品中我们会发现</p><p>在上级的绝对指令和你心中的善的对立中</p><p>你自己也许也不知道应该会怎么做（在你还不知道未来的剧情走向时）</p><p><strong>人是一种很复杂的生物</strong></p><p>所以我不禁怀疑，世界上到底是否有<strong>“绝对的正”</strong>与<strong>“绝对的恶”</strong>呢？</p><p>也许这种 <strong>“恶”</strong> 是我们的 <strong>偏见</strong> 所导致的呢？</p><p>所以我们没有任何的权利去评判一个人的三观正不正</p><p>因为三观正，往往是基于你自身的一种考量</p><h1 id="三观给我们带来的影响"><a href="#三观给我们带来的影响" class="headerlink" title="三观给我们带来的影响"></a>三观给我们带来的影响</h1><p>三观，由于是我们人的思考的产物</p><p>所以每一个人都可以去解读它</p><p><strong>我们看待世界的方式往往会因为我们的三观所左右</strong></p><p><img src="/img/%E4%B8%BE%E4%BE%8B.jpg" srcset="/img/loading.gif" alt="举例.jpg"></p><p>举一个例子，伟大的物理学家，数学学家牛顿<br>在他的一生中有许许多多的伟大壮举<br>牛顿的一生都在和神学打交道<br>为什么这么说呢？<br>牛顿对科学的研究，其目的在于发现上帝所设置的世界规律<br>牛顿并没有跳出他心中所想的上帝<br>或者说他是想要证明出他心中的那位上帝</p><p>通过这个例子，我们不难发现，我们现在所做的任何事</p><p><strong>都会因为我们的三观而左右</strong></p><p>我觉得牛顿的三观，正是因为上帝的影响吧</p><h1 id="三观，成长环境的缩影"><a href="#三观，成长环境的缩影" class="headerlink" title="三观，成长环境的缩影"></a>三观，成长环境的缩影</h1><p>在我们去跟其他的人去谈话的时候</p><p>我们就可以发现<strong>谈话两者</strong>的三观的偏差</p><p>比如在生活拮据的家生活的人和含着金钥匙长大的人是不一样的</p><p>在我看来这其实是三观的原因</p><p>在我们所处的环境中，<strong>成长环境</strong>对三观的影响是最大的</p><p>为什么会这么说？</p><p>中国政法大学教授，罗翔老师是一位我非常喜欢的老师</p><p>他就在他的书《圆圈正义》里面说过</p><blockquote><p>我是一名湖南人，从小我就一身为湖南人而骄傲。我瞧不起一切外省的人与事——惟楚有材，于斯为盛，“大江东去，无非湘水余波”，岳麓书院的这句对联让我对湖湘文化无比自豪，也让我对外省人不屑一顾（我甚至还自撰“大海翻腾，无非湘水涟漪”）</p></blockquote><blockquote><p>罗翔.圆圈正义.中国法制出版社，2019.08：115.</p></blockquote><p>我们不难发现罗翔老师在当时也是一名“地域黑”</p><p>这个概念其实是受到其三观的影响，而三观又是受到其成长环境的影响</p><p>成长环境又有很多种可变的因素，比如</p><ul><li>后天教育</li><li>家庭关系</li><li>自身的思考</li><li>对外面世界的探索</li><li>自己家庭拥有的资源等</li></ul><p>所以<strong>三观是具有可塑性的</strong></p><h1 id="如果我们的三观受到外来影响会怎么样呢？"><a href="#如果我们的三观受到外来影响会怎么样呢？" class="headerlink" title="如果我们的三观受到外来影响会怎么样呢？"></a>如果我们的三观受到外来影响会怎么样呢？</h1><p>我们现在往往会听到一个名词</p><p><strong>“消费主义”</strong></p><p>比如，现推出双十一购物节，七夕节限定套餐，钻石定制（通常是跟一句XX永相伴的slogan）等活动</p><p>我们发现这些京东618，天猫双11逐渐得离不开我们的生活</p><p>好像每年的购物节不买点什么都觉得对不起自己似的</p><p>而在此期间我们的价值观，便会逐渐的被消费主义所影响</p><p>进而导致我们有购物的欲望与动机</p><p>首先，购物不是一件坏事</p><p>而过度的购物却要不得</p><p>在以前，我们会使用信用卡来进行消费</p><p>而现在开始使用花呗，京东白条等</p><p>我们往往会在新闻上看到“卡奴”这样的字眼</p><p>过度的消费会导致浪费</p><p>这样的价值观对我们的生活产生了不必要的浪费</p><p><strong>所以我们作为自己三观的主人</strong></p><p><strong>要主动引导自己的三观</strong></p><p><strong>去看到生活中那些你不曾看到过的</strong></p><p><strong>进而你便能去塑造自己的三观</strong></p><p>最后给大家送上罗翔老师的《圆圈正义》中的一句话</p><blockquote><p>我们求学问道，读万卷书，行万里路，就是为了走出我们基于地域、血统、国族所形成的偏见</p></blockquote><h1 id="2021-5-2的补充"><a href="#2021-5-2的补充" class="headerlink" title="2021/5/2的补充"></a>2021/5/2的补充</h1><p>在经过马原的学习之后，我对于三观正这一概念又有了全新的认识</p><p>其实我们所说的正确的价值观，是符合广大民众利益的由全社会共同认可的核心价值观</p><p>我们离不开这个社会，社会也离不开我们</p><p>而社会中共有的核心价值，也许这应该就是所谓的三观正吧</p><blockquote><p>“社会主义核心价值观是当代中国精神的集中体现，凝结着全体人民共同的价值追求。” —— 习近平<br>习近平: 《决胜全面建成小康社会  夺取新时代中国特色社会主义伟大胜利 —— 在中国共产党第十九次全国代表大会上的报告》, 人民出版社2017版, 第42页。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>唠嗑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>唠嗑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我们是什么时候开始变得不爱思考了？</title>
    <link href="/2020/08/30/%E6%88%91%E4%BB%AC%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BC%80%E5%A7%8B%E5%8F%98%E5%BE%97%E4%B8%8D%E7%88%B1%E6%80%9D%E8%80%83%E4%BA%86%EF%BC%9F/"/>
    <url>/2020/08/30/%E6%88%91%E4%BB%AC%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BC%80%E5%A7%8B%E5%8F%98%E5%BE%97%E4%B8%8D%E7%88%B1%E6%80%9D%E8%80%83%E4%BA%86%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章其实也可以说为</p><p>“我们是什么时候开始变得难以深度思考了？”</p><p>作为一名准大二的在校大学生</p><p>我应是没有资格来谈这种事的</p><p>但是我依然会将我的想法阐述出来，尽管这看起来会有点自负</p><h1 id="学习分组"><a href="#学习分组" class="headerlink" title="学习分组"></a>学习分组</h1><p>我只是一名在校的大学生，就难免需要去完成一些学校的作业</p><p>那么在大学里面，团体小组的作业是最常见的</p><p>所以我们通常会分成好几个小组</p><p>那么在分完组之后我们往往会面对第一个问题</p><p><strong><em>谁是组长？</em></strong></p><p>这个问题其实说起来并不复杂，但是在确定组长的时候</p><p>每个组员都会将所有人与自己心中所谓的<strong>“标准”</strong>进行比对</p><p>直到我们遇到了一个能够比较符合该<strong>“标准”</strong>的一个人时我们便会进行确定所选定的人</p><p>最终组长便确定了下来，通常情况下，他往往是一名有先前经验，并且能够做好这份任务的人</p><h1 id="组内事项"><a href="#组内事项" class="headerlink" title="组内事项"></a>组内事项</h1><p>那么作为一名在校的大学生，我也自然而然的经历过此类事件，并且也做过项目组长</p><p>在我做组长的时候，我发现了一些很有意思的事</p><ul><li><p>组员往往不会去仔细地查阅相关资料</p></li><li><p>组员往往需要组长的<strong>催促</strong>才能完成任务</p></li><li><p>大部分的组员往往会因为不清楚项目<strong>所需的东西</strong>，而往往完成的任务质量都不尽人意</p></li></ul><p>不知道有没有说中部分人啊，这里我就拿了我所看到的情况进行分享</p><p>那么我们就从这简简单单的三条内容我们不难发现</p><p>这不就是当代的“社畜”每天都要做的事吗？</p><p>作为一名大学生，我们已经开始经历我们未来所要天天经历的事</p><h1 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h1><p>首先，我对此查阅了相关的资料，我发现这是一种叫做 <a href="https://wiki.mbalib.com/wiki/%E7%A4%BE%E4%BC%9A%E6%83%B0%E5%8C%96" target="_blank" rel="noopener">社会惰化</a> 的现象</p><blockquote><p>所谓社会惰化，是指个人与群体其他成员一起完成某种事情时，或个人活动时有他人在场，往往个人所付出的努力比单独时偏少，不如单干时出力多，个人的活动积极性与效率下降的现象，也称之为社会惰化作用，另也叫<strong>社会干扰、社会致弱、社会逍遥、社会懈怠</strong>。</p></blockquote><p>那么对于这些现象我又有了一些思考，为什么组员会对自己的任务不上心呢？</p><p>不去专心，严谨的进行研究，查阅资料，而去百度<strong>无考究的主观的</strong>答案</p><p>在我看来，可能有以下几点</p><ol><li>组员并不想做项目，来到该组只是为了完成作业</li><li>组员不知道应该如何去做，如何去完成这些任务</li><li>组员有可能是一时头脑发热，就加入了该组项目</li><li>组员可能是因为这个组有大腿可以抱，于是从主观上对任务的完成度就理所当然的不想去提高任务质量，即“反正有人帮我改”的思想<br>……</li></ol><p>上方的几个点只是我一时半会想到的，不具有严谨性（都写博客了谁还在意严谨…</p><p>在思考上方的第二个问题的时候，我突然发现了一个新的问题</p><p><strong>“我们是否在丧失着自主思考的能力？”</strong></p><h1 id="我们是否在丧失着自主思考的能力？"><a href="#我们是否在丧失着自主思考的能力？" class="headerlink" title="我们是否在丧失着自主思考的能力？"></a>我们是否在丧失着自主思考的能力？</h1><p>为什么我会有这样的联想？说起来我也不知道</p><p>写到此，我不禁想到了上个世纪的中国</p><p>那时候的知识分子都在做些什么呢？</p><p>做氢弹，做原子弹</p><p>而对于这类具有军事意义的技术</p><p>我们在那时候并没有先前的案例进行参考</p><p>他们完完全全是通过自己一步步的试错与国外学者或文献的交流当中进行学习</p><p>最后，氢弹，原子弹都造出来了</p><p>那么写到这里，我开始思考过去的人们与现在的大学生</p><p>他们和我们又有什么不同呢？</p><p>很显然我们当下所拥有的的资源，是以往不及的</p><p>但是我们却缺少了他们的那一份探索未知的勇气</p><h1 id="信息时代的大爆炸"><a href="#信息时代的大爆炸" class="headerlink" title="信息时代的大爆炸"></a>信息时代的大爆炸</h1><p>在我们反观现在的社会，抖音，微博，Bilibili，微信公众号等大量的社交，娱乐软件都在充斥着我们的生活</p><p>根据马斯洛需求理论来说，在人们拥有了生理需求与安全需求之后，所需要的便是社交需求</p><p>很显然，这些软件，都是抓住了这一需求</p><p>使得我们逐渐的离不开这些软件</p><p>可是在大量的信息充斥着我们的生活之后</p><p>我们反而变得更加的<strong>“懒惰”</strong>了</p><p>要注意这里的<strong>“懒惰”</strong>我是打了双引号的</p><p>我的意思是说，<strong>我们逐渐失去了如何去寻找有用信息的能力</strong></p><p>跟上世纪不同的是，那时候的大学生在信息网络不发达的情况下，通过书籍资料进行学习</p><p>而我们现在每天刷的抖音或Bilibili等，他们往往会推送一些娱乐信息给我们</p><p>我们不难发现</p><p>以前的我们是主动的去寻求答案</p><p>而现在的我们则是被动的去接受答案</p><p>以至于我们会发现我们需要比以往更久的时间去查阅关键信息</p><p>在我看来，有可能原因就是我们平时缺少一定的深度思考吧</p><p>我们会发现人变的更“懒”了</p><p>有的人会说，人的懒惰代表着科技会进步</p><p>这点在一定程度上有它的道理所在</p><p>但是我们是去做改变社会的人，还是要去做被社会改变的人</p><p>这个是我们要思考的问题</p><p>在每次我想偷懒的时候我往往会想一个问题</p><p><strong>“十年后的我还有没有机会能像现在这样玩手机呢？”</strong></p>]]></content>
    
    
    <categories>
      
      <category>唠嗑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>唠嗑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>久违的博客更新</title>
    <link href="/2020/08/14/%E4%B9%85%E8%BF%9D%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0/"/>
    <url>/2020/08/14/%E4%B9%85%E8%BF%9D%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<p>距离我上一次发博文的时候还是四月初，而现在却是八月中旬了  </p><p>期间发生了什么事呢？  </p><p>首先我考完了我大一的最后一场考试，并且只是获得了平均绩点3.44的成绩，很辣鸡  </p><p>之后我把我的绿宝石全部给卖出，赚取了8800的收入，于是我便买了一台主机和显示器，配置如下<br><img src="/img/%E9%85%8D%E7%BD%AE.png" srcset="/img/loading.gif" alt=""></p><p>很辣鸡的配置，包括显示器花了5300，心痛…</p><p>此外，对于以后的计划，我可能还会继续出相关的教程，或者更新一些我自己看了一些电影之后的想法吧。</p>]]></content>
    
    
    <categories>
      
      <category>唠嗑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>唠嗑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的所有公开的教程</title>
    <link href="/2020/04/05/%E6%88%91%E7%9A%84%E6%89%80%E6%9C%89%E5%85%AC%E5%BC%80%E7%9A%84%E6%95%99%E7%A8%8B/"/>
    <url>/2020/04/05/%E6%88%91%E7%9A%84%E6%89%80%E6%9C%89%E5%85%AC%E5%BC%80%E7%9A%84%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Bukkit插件开发-视频"><a href="#Bukkit插件开发-视频" class="headerlink" title="Bukkit插件开发 | 视频"></a>Bukkit插件开发 | 视频</h1><ul><li><a href="https://www.mcbbs.net/thread-684323-1-1.html" target="_blank" rel="noopener">Bukkit插件开发 - 从入门到弃坑(索引)</a><blockquote><p>这个教程适合<strong>Minecraft1.12以下</strong>的版本, 1.13以上的版本建议还是去看别的作者的吧</p></blockquote></li><li><a href="https://www.bilibili.com/video/BV1o7411J7gM/" target="_blank" rel="noopener">[动画版]Minecraft粒子教程(一) 这个教程明明通俗易懂却过分简短</a><blockquote><p>这个教程主要是试试<code>manim</code>引擎来制作数学动画, 总的来说, <strong>适合入门</strong></p></blockquote></li></ul><h1 id="Bukkit插件开发"><a href="#Bukkit插件开发" class="headerlink" title="Bukkit插件开发"></a>Bukkit插件开发</h1><ul><li><p><a href="https://www.mcbbs.net/thread-792576-1-1.html" target="_blank" rel="noopener">如何给实体增加NBT数据</a></p><blockquote><p>这个教程主要是利用了 <code>org.bukkit.attribute</code> 包下的内容进行操作<br>因为在高版本时, 给实体设置最大血量最好还是使用NBT来做</p></blockquote></li><li><p><a href="https://www.mcbbs.net/thread-897858-1-1.html" target="_blank" rel="noopener">可能是最简单的Scoreboard教程</a></p><blockquote><p>这个教程主要使用了 <code>org.bukkit.scoreboard</code> 包下的相关内容进行了操作<br>本教程写于2020-3-22日, 理论上来说可以兼容1.8-1.15.2</p><ul><li>基础使用</li><li>无闪计分板</li><li>计分板自带的Team</li></ul></blockquote></li></ul><h1 id="Minecraft粒子教程"><a href="#Minecraft粒子教程" class="headerlink" title="Minecraft粒子教程"></a>Minecraft粒子教程</h1><ul><li><a href="https://www.mcbbs.net/thread-837600-1-1.html" target="_blank" rel="noopener">从零开始的MC特效(索引)</a><blockquote><p>这个帖子在我的<strong>简书</strong>上也有介绍, 详情可以点击<a href="https://www.jianshu.com/p/cf267acfe719" target="_blank" rel="noopener">这里</a><br>其中有如下的几个章节</p><ul><li>一、在X, Z轴上的画圆操作</li><li>二、向量基础</li><li>三、向量的旋转</li><li>四、Sin函数与Cos函数在Y轴上体现</li><li>五、BukkitRunnable与粒子特效</li><li>六、坐标系的旋转</li></ul></blockquote></li></ul><h1 id="NMS类"><a href="#NMS类" class="headerlink" title="NMS类"></a>NMS类</h1><ul><li><p><a href="https://www.mcbbs.net/thread-811096-1-1.html" target="_blank" rel="noopener">如何自定义你的实体</a></p><blockquote><p>这个教程主要适用于<strong>1.12以下</strong>的版本使用, 更高的版本请查询这个教程: <a href="https://www.mcbbs.net/thread-966358-1-1.html" target="_blank" rel="noopener">点我</a></p><ul><li>自定义僵尸</li><li>实体的WASD移动</li><li>PathfinderGoal (实体AI)</li><li>Navigation (实体的寻路系统)</li></ul></blockquote></li><li><p><a href="https://www.mcbbs.net/thread-697478-1-1.html" target="_blank" rel="noopener">如何给物品增加NBT数据</a></p><blockquote><p>这个教程主要是使用了NMS下的 <code>NBTTagCompound</code>, 并对物品进行增加, 查找, 删除NBT数据的操作进行的讲解</p></blockquote></li></ul><h1 id="其他教程"><a href="#其他教程" class="headerlink" title="其他教程"></a>其他教程</h1><ul><li><a href="https://www.mcbbs.net/thread-711754-1-1.html" target="_blank" rel="noopener">如何利用Maven来管理你的插件</a><blockquote><p>看看就好…毕竟只是以前的<em>屑文章</em></p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit教程</tag>
      
      <tag>其他教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单利与复利的计算</title>
    <link href="/2020/04/02/%E5%8D%95%E5%88%A9%E4%B8%8E%E5%A4%8D%E5%88%A9%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <url>/2020/04/02/%E5%8D%95%E5%88%A9%E4%B8%8E%E5%A4%8D%E5%88%A9%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<center><font size="5" color="dark">本节内容主要是我在课上的笔记</font></center><p>$$利息率 = \frac{利息}{本金} \times 100\%$$<br>利息 = <strong>补偿、报偿、代价、收益、利润、价格、剩余价值</strong><br>0.35%活期存款 100<br>$$社会平均利率率 &gt; 利息率 &gt; 0$$<br><a href="https://baike.baidu.com/item/%E5%88%A9%E7%8E%87%E5%80%92%E6%8C%82" target="_blank" rel="noopener">利率倒挂</a></p><hr><h3 id="利息的计算"><a href="#利息的计算" class="headerlink" title="利息的计算:"></a>利息的计算:</h3><ol><li>为期5年，年利率6% 10万元贷款<br>以单利和复利算出应缴利息</li></ol><ul><li><p>单利:</p><blockquote><p>解: 本金100000元，年利率6%，期限5年<br>∵ $利息率 = \frac{利息}{本金} \times 100\%$<br>计算公式为:<br>$$I = P \times R \times N\\I=利息;P=本金;\\R=利率;N=时间$$<br>∴ $100000 \times 6\% \times 5 = 30000(元)$<br>故: 单利的应缴利息为 30000 元</p></blockquote></li><li><p>复利: </p><blockquote><p>∵ 计算公式为: $$S = P \times (1 + R)^N\\I = S - P\\I=应缴利息; S=本息和\\P=本金; R=利率; N=时间$$<br>∴ 代入公式计算得: $100000 \times (1 + 6\%)^5 = 133822.56(元)$<br>故本息和为$133822.56$<br>则利息为$133822.56 - 100000 = 33822.56(元)$</p></blockquote><h4 id="计息时-期限单位与利率的期限单位一致"><a href="#计息时-期限单位与利率的期限单位一致" class="headerlink" title="(计息时, 期限单位与利率的期限单位一致!!!)"></a>(计息时, <strong>期限单位</strong>与<strong>利率的期限</strong>单位一致!!!)</h4></li></ul><hr><h3 id="现值与终值"><a href="#现值与终值" class="headerlink" title="现值与终值"></a>现值与终值</h3><p>现值 PV(Present Value)<br>终值 FV(Future Value)</p><p>本=50000元, r=5%, n=3年<br>$$FV = PV \times (1+r)^n$$</p><blockquote><p>解: $50000 \times (1 + 5\%)^3 = 57881.25(元)$</p></blockquote><hr><h3 id="利率的区分与换算"><a href="#利率的区分与换算" class="headerlink" title="利率的区分与换算:"></a>利率的区分与换算:</h3><p>看到百分之几：5%的，年息5厘<br>$$月利率 = \frac{5\%}{12}\\日利率 = \frac{5\%}{360}$$</p><hr><p>看到千分之几：3‰的，月息3厘<br>$$年利率 = 3‰\times12\\日利率 = \frac{3‰}{30}$$</p><hr><p>看到万分之几: 2.5‱的 日息2.5厘<br>$$月利率 = 2.5‱\times30\\年利率 = 2.5‱\times360$$</p><hr><center><font size="30">所以总的来说</font></center>$$月利率 = 日利率 \times 30\\\\年利率 = 月利率 \times 12$$]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>金融学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX与Markdown</title>
    <link href="/2020/04/02/Latex%E4%B8%8EMarkdown/"/>
    <url>/2020/04/02/Latex%E4%B8%8EMarkdown/</url>
    
    <content type="html"><![CDATA[<p>$$LaTeX$$<br>总所周知, LaTeX是一个优秀的基于TeX的文档排版系统。<br>在Markdown中插入数学公式的语法是 <code>$数学公式$</code> 和 <code>$$数学公式$$</code>。</p><hr><h1 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h1><p>行内公式是可以让公式在文中与文字或其他东西混编，<strong>不独占一行</strong>.在数学模式下, 符号会使用单独的字体<br>字母通常是<em>倾斜</em>的意大利体, 数字和符号则是直立体. 而且,数学符号之间的距离也与一般的水平模式不同:</p><table><thead><tr><th>实例</th><th>显示</th></tr></thead><tbody><tr><td><code>$2x+3y=34$</code></td><td>$2x+3y=34$</td></tr><tr><td>2x+3y=34</td><td>2x+3y=34</td></tr></tbody></table><hr><h1 id="独立公式"><a href="#独立公式" class="headerlink" title="独立公式"></a>独立公式</h1><p>独立公式顾名思义，就是单独的占一行<br>比如 <code>$$E = mc^2$$</code> 其可以展示为<br>$$E = mc^2$$</p><p>它单独占用了一行, 而不是在 <strong>单行</strong> 内显示</p><hr><h1 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h1><p>在独立公式中使用\\来换行<br>示例: </p><pre><code class="hljs angelscript">$$<span class="hljs-number">2</span>x+<span class="hljs-number">3</span>y=<span class="hljs-number">34</span>\\x+<span class="hljs-number">4</span>y=<span class="hljs-number">25</span>$$</code></pre><p>显示:<br>$$<br>2x+3y=34\\<br>x+4y=25<br>$$</p><blockquote><p><strong>如果你的解析器会自动转义, 那么请写四个 <code>\\\\</code></strong></p></blockquote><hr><h1 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h1><table><thead><tr><th>符号</th><th>实例</th><th>显示</th></tr></thead><tbody><tr><td>上下标</td><td><code>S=a_{1}^2+a_{2}^2+a_{3}^2$</code></td><td>$S=a_{1}^2+a_{2}^2+a_{3}^2$</td></tr><tr><td>括号</td><td><code>$f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace$</code></td><td>$f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace$</td></tr><tr><td>分数</td><td><code>$\frac{1}{3} 与 \cfrac{1}{3}$</code></td><td>$\frac{1}{3} 与 \cfrac{1}{3}$</td></tr><tr><td>开方</td><td><code>$\sqrt[3]{X}$ 和 $\sqrt{5 - x}$</code></td><td>$\sqrt[3]{X}$ 和 $\sqrt{5 - x}$</td></tr></tbody></table><hr><h1 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h1><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th>符号</th><th>显示</th></tr></thead><tbody><tr><td><code>\pm</code></td><td>$\pm$</td></tr><tr><td><code>\times</code></td><td>$\times$</td></tr><tr><td><code>\div</code></td><td>$\div$</td></tr><tr><td><code>\mid</code></td><td>$\mid$</td></tr><tr><td><code>\nmid</code></td><td>$\nmid$</td></tr><tr><td><code>\cdot</code></td><td>$\cdot$</td></tr><tr><td><code>\circ</code></td><td>$\circ$</td></tr><tr><td><code>\ast</code></td><td>$\ast$</td></tr><tr><td><code>\bigodot</code></td><td>$\bigodot$</td></tr><tr><td><code>\bigotimes</code></td><td>$\bigotimes$</td></tr><tr><td><code>\bigoplus</code></td><td>$\bigoplus$</td></tr><tr><td><code>\leq</code></td><td>$\leq$</td></tr><tr><td><code>\geq</code></td><td>$\geq$</td></tr><tr><td><code>\neq</code></td><td>$\neq$</td></tr><tr><td><code>\approx</code></td><td>$\approx$</td></tr><tr><td><code>\equiv</code></td><td>$\equiv$</td></tr><tr><td><code>\sum</code></td><td>$\sum$</td></tr><tr><td><code>\prod</code></td><td>$\prod$</td></tr></tbody></table><hr><h2 id="对数运算符"><a href="#对数运算符" class="headerlink" title="对数运算符"></a>对数运算符</h2><table><thead><tr><th>符号</th><th>显示</th></tr></thead><tbody><tr><td><code>\log</code></td><td>$\log$</td></tr><tr><td><code>\lg</code></td><td>$\lg$</td></tr><tr><td><code>\ln</code></td><td>$\ln$</td></tr></tbody></table><hr><h2 id="三角运算符"><a href="#三角运算符" class="headerlink" title="三角运算符"></a>三角运算符</h2><table><thead><tr><th>符号</th><th>显示</th></tr></thead><tbody><tr><td><code>\bot</code></td><td>$\bot$</td></tr><tr><td><code>\angle</code></td><td>$\angle$</td></tr><tr><td><code>\sin</code></td><td>$\sin$</td></tr><tr><td><code>\cos</code></td><td>$\cos$</td></tr><tr><td><code>\tan</code></td><td>$\tan$</td></tr><tr><td><code>\cot</code></td><td>$\cot$</td></tr><tr><td><code>\sec</code></td><td>$\sec$</td></tr><tr><td><code>\csc</code></td><td>$\csc$</td></tr></tbody></table><hr><h2 id="微积分运算符"><a href="#微积分运算符" class="headerlink" title="微积分运算符"></a>微积分运算符</h2><table><thead><tr><th>符号</th><th>显示</th></tr></thead><tbody><tr><td><code>\prime</code></td><td>$\prime$</td></tr><tr><td><code>\int</code></td><td>$\int$</td></tr><tr><td><code>\iint</code></td><td>$\iint$</td></tr><tr><td><code>\iiint</code></td><td>$\iiint$</td></tr><tr><td><code>\oint</code></td><td>$\oint$</td></tr><tr><td><code>\lim</code></td><td>$\lim$</td></tr><tr><td><code>\infty</code></td><td>$\infty$</td></tr><tr><td><code>\nabls</code></td><td>$∇$</td></tr><tr><td><code>\mathrm{d}</code></td><td>$\mathrm{d}$</td></tr></tbody></table><hr><h2 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h2><table><thead><tr><th>符号</th><th>显示</th></tr></thead><tbody><tr><td><code>\emptyset</code></td><td>$\emptyset$</td></tr><tr><td><code>\in</code></td><td>$\in$</td></tr><tr><td><code>\notin</code></td><td>$\notin$</td></tr><tr><td><code>\subset</code></td><td>$\subset$</td></tr><tr><td><code>\subseteq</code></td><td>$\subseteq$</td></tr><tr><td><code>\supseteq</code></td><td>$\supseteq$</td></tr><tr><td><code>\bigcap</code></td><td>$\bigcap$</td></tr><tr><td><code>\bigcup</code></td><td>$\bigcup$</td></tr><tr><td><code>\bigvee</code></td><td>$\bigvee$</td></tr><tr><td><code>\bigwedge</code></td><td>$\bigwedge$</td></tr><tr><td><code>\biguplus</code></td><td>$\biguplus$</td></tr><tr><td><code>\bigsqcup</code></td><td>$\bigsqcup$</td></tr></tbody></table><hr><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table><thead><tr><th>代码</th><th>大写</th><th>代码</th><th>小写</th></tr></thead><tbody><tr><td><code>A</code></td><td>$A$</td><td><code>\alpha</code></td><td>$\alpha$</td></tr><tr><td><code>B</code></td><td>$B$</td><td><code>\beta</code></td><td>$\beta$</td></tr><tr><td><code>\Gamma</code></td><td>$\Gamma$</td><td><code>\gamma</code></td><td>$\gamma$</td></tr><tr><td><code>\Delta</code></td><td>$\Delta$</td><td><code>\delta</code></td><td>$\delta$</td></tr><tr><td><code>E</code></td><td>$E$</td><td><code>\epsilon</code></td><td>$\epsilon$</td></tr><tr><td><code>Z</code></td><td>$Z$</td><td><code>\zeta</code></td><td>$\zeta$</td></tr><tr><td><code>H</code></td><td>$H$</td><td><code>\eta</code></td><td>$\eta$</td></tr><tr><td><code>\Theta</code></td><td>$\Theta$</td><td><code>\theta</code></td><td>$\theta$</td></tr><tr><td><code>I</code></td><td>$I$</td><td><code>\iota</code></td><td>$\iota$</td></tr><tr><td><code>K</code></td><td>$K$</td><td><code>\kappa</code></td><td>$\kappa$</td></tr><tr><td><code>Lambda</code></td><td>$Lambda$</td><td><code>\lambda</code></td><td>$\lambda$</td></tr><tr><td><code>M</code></td><td>$M$</td><td><code>\mu</code></td><td>$\mu$</td></tr><tr><td><code>N</code></td><td>$N$</td><td><code>\nu</code></td><td>$\nu$</td></tr><tr><td><code>Xi</code></td><td>$Xi$</td><td><code>\xi</code></td><td>$\xi$</td></tr><tr><td><code>O</code></td><td>$O$</td><td><code>\omicron</code></td><td>$\omicron$</td></tr><tr><td><code>\Pi</code></td><td>$\Pi$</td><td><code>\pi</code></td><td>$\pi$</td></tr><tr><td><code>P</code></td><td>$P$</td><td><code>\rho</code></td><td>$\rho$</td></tr><tr><td><code>\Sigma</code></td><td>$\Sigma$</td><td><code>\sigma</code></td><td>$\sigma$</td></tr><tr><td><code>T</code></td><td>$T$</td><td><code>\tau</code></td><td>$\tau$</td></tr><tr><td><code>\Upsilon</code></td><td>$\Upsilon$</td><td><code>\upsilon</code></td><td>$\upsilon$</td></tr><tr><td><code>\Phi</code></td><td>$\Phi$</td><td><code>\phi</code></td><td>$\phi$</td></tr><tr><td><code>X</code></td><td>$X$</td><td><code>\chi</code></td><td>$\chi$</td></tr><tr><td><code>\Psi</code></td><td>$\Psi$</td><td><code>\psi</code></td><td>$\psi$</td></tr><tr><td><code>\Omega</code></td><td>$\Omega$</td><td><code>\omega</code></td><td>$\omega$</td></tr></tbody></table><hr><h2 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h2><table><thead><tr><th>符号</th><th>显示</th></tr></thead><tbody><tr><td><code>(</code></td><td>$($</td></tr><tr><td><code>)</code></td><td>$($</td></tr><tr><td><code>[ 或 \lbrack</code></td><td>$\lbrack$</td></tr><tr><td><code>] 或 \rbrack</code></td><td>$\rbrack$</td></tr><tr><td><code>\{ 或\lbrace</code></td><td>$($</td></tr><tr><td><code>\} 或\rbrace</code></td><td>$($</td></tr><tr><td><code>\langle</code></td><td>$\langle$</td></tr><tr><td><code>\rangle</code></td><td>$\rangle$</td></tr><tr><td><code>\lfloor</code></td><td>$\lfloor$</td></tr><tr><td><code>\rfloor</code></td><td>$\rfloor$</td></tr><tr><td><code>/</code></td><td>$/$</td></tr><tr><td><code>\backslash</code></td><td>$\backslash$</td></tr><tr><td><code>\uparrow</code></td><td>$\uparrow$</td></tr><tr><td><code>\Uparrow</code></td><td>$\Uparrow$</td></tr><tr><td><code>\downarrow</code></td><td>$\downarrow$</td></tr><tr><td><code>\Downarrow</code></td><td>$\Downarrow$</td></tr><tr><td><code>\updownarrow</code></td><td>$\updownarrow$</td></tr><tr><td><code>\Updownarrow</code></td><td>$\Updownarrow$</td></tr><tr><td><code>\leftarrow</code></td><td>$\leftarrow$</td></tr><tr><td><code>\Leftarrow</code></td><td>$\Leftarrow$</td></tr><tr><td><code>\rightarrow</code></td><td>$\rightarrow$</td></tr><tr><td><code>\Rightarrow</code></td><td>$\Rightarrow$</td></tr><tr><td><code>\vert</code></td><td>$\vert$</td></tr><tr><td><code>\Vert</code></td><td>$\Vert$</td></tr><tr><td><code>\lceil</code></td><td>$\lceil$</td></tr><tr><td><code>\rceil</code></td><td>$\rceil$</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>其他教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可能是最简单Scoreboard教程</title>
    <link href="/2020/03/29/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E7%AE%80%E5%8D%95Scoreboard%E6%95%99%E7%A8%8B/"/>
    <url>/2020/03/29/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E7%AE%80%E5%8D%95Scoreboard%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h2><ul><li>导读</li><li>Scoreboard的基本概念</li><li>使用Scoreboard进行展示数据给玩家</li><li>制作无闪计分板</li><li>如何使用Minecraft自带的Team</li></ul><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><del>好久没有更新教程了，woc昨天就发过教程（锡兰梗</del></p><p>本教程使用的 PaperSpigot1.15.2-R0.1-SNAPSHOT 核心<br>在阅读之前请确保你具有Java基础的知识<strong>(别问，问就挨打)</strong></p><p>To 读者: 本教程适合所有年龄向的人，因为我们是面向剪切板编程</p><h2 id="Scoreboard的基本概念"><a href="#Scoreboard的基本概念" class="headerlink" title="Scoreboard的基本概念"></a>Scoreboard的基本概念</h2><p>在教程开始前我们来了解一下Scoreboard  </p><ul><li><strong>记分板</strong>（Scoreboard）系统是一套通过命令操纵的复杂游戏机制。主要为地图作者与服务器运营者准备，记分板可用多种形式追踪、设置并列出玩家及实体的分数。</li><li><strong>记分项</strong>（Objective）由<strong>名称</strong>（name）、<strong>显示名称</strong>（display name）、<strong>准则</strong>（criteria）以及每位玩家（及实体UUID）所对应的整数数据组成。分数的范围为<strong>-2,147,483,648</strong>至<strong>2,147,483,647</strong>没有小数。</li><li><a href="https://minecraft-zh.gamepedia.com/%E8%AE%B0%E5%88%86%E6%9D%BF#.E5.87.86.E5.88.99" target="_blank" rel="noopener">准则(criteria)</a></li><li><a href="https://minecraft-zh.gamepedia.com/%E8%AE%B0%E5%88%86%E6%9D%BF#.E6.98.BE.E7.A4.BA.E4.BD.8D.E7.BD.AE" target="_blank" rel="noopener">显示位置(DisplaySlot)</a></li></ul><p><strong>若读者有制作CB的经验，那么上方的基本概念可以跳过</strong></p><p>在有了上方对记分板的基本概念后，我们来查询一下Bukkit API中对Scoreboard的包装</p><p><a href="http://docs.zoyn.top/bukkitapi/1.12.2/org/bukkit/scoreboard/Scoreboard.html" target="_blank" rel="noopener">1.12.2版本</a> | <a href="https://www.mcbbs.net/plugin.php?id=link_redirect&target=https%3A%2F%2Fbukkit.windit.net%2Fjavadoc%2Findex.html%3Forg%2Fbukkit%2Fscoreboard%2Fpackage-summary.html">1.13+版本</a><br><a href="https://www.mcbbs.net/plugin.php?id=link_redirect&target=https%3A%2F%2Fhub.spigotmc.org%2Fjavadocs%2Fspigot%2Findex.html%3Forg%2Fbukkit%2Fscoreboard%2Fpackage-summary.html">Spigot最新版本</a></p><p><em>我吹爆中文BukkitAPI</em></p><p>可以在上方的Javadoc的查询知道，在Bukkit当中，所有关于Scoreboard的操作都被放到 <em>org.bukkit.scoreboard</em> 包下了，之后我们就来看一下，要怎么正确的使用一个记分板吧</p><p><strong><em>在阅读教程之前我强烈建议先看一看中文MinecraftWiki再来阅读本文</em></strong></p><h3 id="使用Scoreboard进行展示数据给玩家"><a href="#使用Scoreboard进行展示数据给玩家" class="headerlink" title="使用Scoreboard进行展示数据给玩家"></a>使用Scoreboard进行展示数据给玩家</h3><p>接下来我们就来看看如何进行操作<br>首先我们需要的是ScoreboardManager这个接口的对象，怎么获取呢？我可以通过下方代码实现</p><pre><code class="hljs reasonml">ScoreboardManager manager = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bukkit</span>.</span></span>get<span class="hljs-constructor">ScoreboardManager()</span>;</code></pre><p>在Bukkit这个静态类中，BukkitAPI已经帮我们造好了轮子，我们可以直接使用<br>接下来我们就需要得到一个叫 <strong>Scoreboard</strong> 接口的对象，我们可以通过manager里的方法来进行获得</p><pre><code class="hljs mipsasm"><span class="hljs-keyword">Scoreboard </span><span class="hljs-keyword">scoreboard </span>= manager.getNewScoreboard();</code></pre><blockquote><p><strong>为什么要用 getNewScoreboard() 呢？</strong><br>因为这样我们只会<strong>新建</strong>出一个Scoreboard，这个Scoreboard是不会受原版指令的限制的Scoreboard</p></blockquote><p>之后我们需要新建一个计分项，也就是Objective，接下来看我的操作</p><pre><code class="hljs nginx"><span class="hljs-attribute">Objective</span> objective = scoreboard.registerNewObjective(<span class="hljs-string">"内部名字"</span>, <span class="hljs-string">"dummy"</span>, <span class="hljs-string">"§a我是展示名~~"</span>);</code></pre><p>首先我们看上面的<strong>三个参数</strong>，name，criteria，displayName，那么对应过来的就是计分项的内部名字和准则与展示名</p><ul><li>内部名字: 用于scoreboard.getObjective()时填入, 可直接获取Objective</li><li>准则: 此 Objective 的准则，表示只能通过插件修改分数</li><li>展示名: 也就是计分板头上的那个标题，比如下图的 Scoreboard 就是展示名<br><img src="https://upload-images.jianshu.io/upload_images/8109631-b081ebf88bdaebe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="Scoreboard.png"></li></ul><blockquote><p><strong>为什么要写 dummy 呢？</strong><br>因为 dummy 型的准则<strong><em>更适合于</em></strong>插件开发, 并且它不会被玩家死亡或击杀变动</p></blockquote><p>之后我们给Objective设置显示的位置</p><pre><code class="hljs css"><span class="hljs-selector-tag">objective</span><span class="hljs-selector-class">.setDisplaySlot</span>(<span class="hljs-selector-tag">DisplaySlot</span><span class="hljs-selector-class">.SIDEBAR</span>);</code></pre><p>我们来解释一下这个显示位置的问题：<br>DisplaySlot这个枚举列举了所有Objective可以存在的地方</p><ul><li>PLAYER_LIST （玩家Tab里）</li><li>SIDEBAR（侧边栏）</li><li>BELOW_NAME （玩家头上NameTag的下面）</li></ul><p>那么接下来我们就要往 Objective 里添加Score了</p><pre><code class="hljs sqf"><span class="hljs-built_in">Score</span> <span class="hljs-built_in">score</span> = objective.getScore(<span class="hljs-string">"内容"</span>);<span class="hljs-built_in">score</span>.setScore(<span class="hljs-number">12345</span>);</code></pre><p>之后我们就可以给玩家设置上我们的Scoreboard<br><strong><em>（如果没有做这一步，并且事先也未给玩家设置Scoreboard的话，会导致无法显示与使用!）</em></strong></p><pre><code class="hljs sqf"><span class="hljs-built_in">Player</span> <span class="hljs-built_in">player</span> = 我也不知道这个<span class="hljs-built_in">player</span>要从哪引用;<span class="hljs-built_in">player</span>.setScoreboard(scoreboard);</code></pre><p><strong>完整代码</strong></p><pre><code class="hljs reasonml">ScoreboardManager manager = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bukkit</span>.</span></span>get<span class="hljs-constructor">ScoreboardManager()</span>;<span class="hljs-comment">// 建立新Scoreboard</span>Scoreboard scoreboard = manager.get<span class="hljs-constructor">NewScoreboard()</span>;<span class="hljs-comment">// 注册新的记分项</span>Objective objective = scoreboard.register<span class="hljs-constructor">NewObjective(<span class="hljs-string">"内部名字"</span>, <span class="hljs-string">"dummy"</span>, <span class="hljs-string">"§a我是展示名~~"</span>)</span>;<span class="hljs-comment">// 设置记分项展示位置</span>objective.set<span class="hljs-constructor">DisplaySlot(DisplaySlot.SIDEBAR)</span>;<span class="hljs-comment">// 给记分项增加 内容与对应的分数</span>Score score = objective.get<span class="hljs-constructor">Score(<span class="hljs-string">"内容"</span>)</span>;score.set<span class="hljs-constructor">Score(12345)</span>;<span class="hljs-comment">// 设置计分板</span>Player player = 我也不知道这个player要从哪引用;player.set<span class="hljs-constructor">Scoreboard(<span class="hljs-params">scoreboard</span>)</span>;</code></pre><p>具体效果:<br><img src="https://upload-images.jianshu.io/upload_images/8109631-6f90b667d3ebd6e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="啦啦啦"></p><h3 id="制作无闪计分板"><a href="#制作无闪计分板" class="headerlink" title="制作无闪计分板"></a>制作无闪计分板</h3><p><strong>问题引入：</strong><br>那么在经过了上面的实例之后我相信，大部分人都已经学会了如何简易的给玩家设置计分板，但是当我们在做一些<strong>动态的</strong>计分板的时候，会出现<strong>闪烁</strong>的问题，那么这是怎么出现的呢？<br>就拿我们刚才的代码来说，如果我们想更改计分板的内容，我们只能通过</p><pre><code class="hljs abnf">scoreboard.resetScores(<span class="hljs-string">"内容"</span>)<span class="hljs-comment">;</span></code></pre><p>这样的方式才能删除一个Score，那么就有人说了</p><ol><li><p>诶呀为什么不直接clear或者reset呢？<br>我也想啊，只可惜Minecraft的计分板就是这么设计的，所以我们如果想更换内容就得先 <strong><em>resetScores()</em></strong> 之后再 <strong><em>objective.getScore()</em></strong> 才能进行更换</p></li><li><p>然后这时候又有人说了，那我重新的getNewScoreboard不就好了吗？<br>诶呀，你自己看看我们上面所写的代码，我们还要注册个新的Objective，之后设置一大堆东西，然后才能开始设置Score，这里面的<strong>实现早已就产生了上百的ms</strong>，所以这个方法会导致闪烁的问题</p></li><li><p>然后这个时候lz就说了，诶呀为什么不用resetScores填入内容之后，再getScore来设置呢？<br>诶呀，这样的话其实还是会导致在 resetScores 的时候出现部分闪屏的内容，属于<strong><em>假无闪！</em></strong>，具体思路是：<br><del>1. 首先我们在 objective.getScore 时顺便将内容存入一个作为cache的List中</del><br><del>2. 在下一次我们想要修改时，遍历这个 cache 的List，之后resetScores</del><br><del>3. 最后再使用 objective.getScore 添加数据</del></p></li></ol><p>那么这时候我们就会出现一个问题，<strong>既然我们不能用 resetScores，那么我们应当怎么写呢？</strong><br>这里我要感谢 <a href="https://www.mcbbs.net/forum.php?mod=redirect&goto=findpost&ptid=897858&pid=17019573" target="_blank" rel="noopener">#6楼</a> 提示给我的方法，所以这里我对解决方案进行更改</p><p>那么这里是我的解决方案:<br>我们通过使用Team的特性来写，Team这个东西其实是，在下面的一部分，但是为了做出无闪的效果，这里提前说一下思路就行</p><ol><li>在Team中有setPrefix和setSuffix的方法，通过这两个方法我们可以<strong>直接修改前后缀</strong></li><li>如果我们新建15个队伍，然后给每个队伍只addEntry(name)，我们为了做出name不显示的效果，我们可以使用颜色代码 §X 的形式做出不显示的效果来实现</li><li>之后我们给每个队伍设置不同的prefix和suffix，这样就可以达到不通过resetScore来设置内容</li></ol><p>我们来看下面的实例</p><h5 id="实例：制作一个实时显示时间的计分板"><a href="#实例：制作一个实时显示时间的计分板" class="headerlink" title="实例：制作一个实时显示时间的计分板"></a>实例：制作一个实时显示时间的计分板</h5><pre><code class="hljs reasonml">import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;import org.bukkit.Bukkit;import org.bukkit.ChatColor;import org.bukkit.entity.Player;import org.bukkit.plugin.Plugin;import org.bukkit.scheduler.BukkitTask;import org.bukkit.scoreboard.DisplaySlot;import org.bukkit.scoreboard.Objective;import org.bukkit.scoreboard.Scoreboard;import org.bukkit.scoreboard.Team;import com.google.common.collect.Lists;public <span class="hljs-keyword">class</span> MyScoreboard &#123;<span class="hljs-keyword">private</span> Scoreboard scoreboard;<span class="hljs-keyword">private</span> Objective objective;<span class="hljs-keyword">private</span> String title;<span class="hljs-keyword">private</span> Player player;<span class="hljs-keyword">private</span> boolean isRun;<span class="hljs-keyword">private</span> SimpleDateFormat format = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd"</span>)</span>;<span class="hljs-keyword">private</span> SimpleDateFormat format2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleDateFormat(<span class="hljs-string">"HH:mm:ss"</span>)</span>;<span class="hljs-comment">// 用作runnable的主类实例</span><span class="hljs-keyword">private</span> Plugin plugin;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用于保存所有的Team</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> List&lt;Team&gt; timers;<span class="hljs-keyword">private</span> BukkitTask task;public <span class="hljs-constructor">MyScoreboard(Plugin <span class="hljs-params">plugin</span>, Player <span class="hljs-params">player</span>, String <span class="hljs-params">title</span>)</span> &#123;this.scoreboard = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bukkit</span>.</span></span>get<span class="hljs-constructor">ScoreboardManager()</span>.get<span class="hljs-constructor">NewScoreboard()</span>;this.title = title;this.objective = scoreboard.register<span class="hljs-constructor">NewObjective(<span class="hljs-params">player</span>.<span class="hljs-params">getName</span>()</span>, <span class="hljs-string">"dummy"</span>, this.title.replace(<span class="hljs-string">"&amp;"</span>, <span class="hljs-string">"§"</span>));objective.set<span class="hljs-constructor">DisplaySlot(DisplaySlot.SIDEBAR)</span>;this.player = player;this.isRun = <span class="hljs-literal">false</span>;this.plugin = plugin;timers = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Lists</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">ArrayList()</span>;&#125;public void start<span class="hljs-constructor">Showing()</span> &#123;<span class="hljs-comment">// 判断是否已经在运行</span><span class="hljs-keyword">if</span> (isRun) &#123;return;&#125;<span class="hljs-keyword">if</span> (player<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>!player.is<span class="hljs-constructor">Online()</span>) &#123;return;&#125;isRun = <span class="hljs-literal">true</span>;player.set<span class="hljs-constructor">Scoreboard(<span class="hljs-params">scoreboard</span>)</span>;<span class="hljs-comment">// 用于保存前15位的内容</span>List&lt;String&gt; tempList = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Lists</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">ArrayList()</span>;for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">15</span>; i++) &#123;tempList.add(<span class="hljs-string">"§"</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatColor</span>.</span></span>values<span class="hljs-literal">()</span><span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.get<span class="hljs-constructor">Char()</span>);&#125;for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">15</span>; i++) &#123;<span class="hljs-comment">// 注册Team时使用 数字的形式就行</span>Team timer = scoreboard.register<span class="hljs-constructor">NewTeam(<span class="hljs-string">""</span> + <span class="hljs-params">i</span>)</span>;<span class="hljs-comment">// addEntry只是作为一个标识符, 用于getScore时的识别</span>timer.add<span class="hljs-constructor">Entry(<span class="hljs-params">tempList</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span>);<span class="hljs-comment">// getScore 刚才的标识符</span>objective.get<span class="hljs-constructor">Score(<span class="hljs-params">tempList</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span>).set<span class="hljs-constructor">Score(<span class="hljs-params">i</span>)</span>;timers.add(timer);&#125;task = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bukkit</span>.</span></span>get<span class="hljs-constructor">Scheduler()</span>.run<span class="hljs-constructor">TaskTimer(<span class="hljs-params">plugin</span>, ()</span> -&gt; &#123;<span class="hljs-keyword">if</span> (!isRun) &#123;return;&#125;for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; timers.size<span class="hljs-literal">()</span>; i++) &#123;Team timer = timers.get(i); <span class="hljs-comment">// 获取每个Team</span>Date date = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>;<span class="hljs-comment">// 设置前缀</span>timer.set<span class="hljs-constructor">Prefix(<span class="hljs-params">tempList</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span> + format.format(date));<span class="hljs-comment">// 设置后缀</span>timer.set<span class="hljs-constructor">Suffix(<span class="hljs-params">tempList</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span> + <span class="hljs-string">" "</span> + format2.format(date));&#125;&#125;, <span class="hljs-number">0L</span>, <span class="hljs-number">20L</span>);&#125;public void turn<span class="hljs-constructor">Off()</span> &#123;isRun = <span class="hljs-literal">false</span>;task.cancel<span class="hljs-literal">()</span>;&#125;&#125;</code></pre><p>具体效果:<img src="https://upload-images.jianshu.io/upload_images/8109631-8e0c7b5277d8f3b7.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="无闪计分板"></p><p><del><strong><em>请不要在意时间，是星空的测试机的锅，我是早睡早起的四好青年</em></strong></del></p><h3 id="如何使用Minecraft自带的Team"><a href="#如何使用Minecraft自带的Team" class="headerlink" title="如何使用Minecraft自带的Team"></a>如何使用Minecraft自带的Team</h3><p>Team这个东西其实是<strong>比较适合Minecraft的</strong>（不然干嘛是Mojang自己做的），因为这个东西你可以设置很多内容，比如说</p><ul><li>COLLISION_RULE（<strong>体积碰撞</strong>）：你可以设置相同队伍可以没有体积碰撞</li><li>DEATH_MESSAGE_VISIBILITY（<strong>死亡信息可见性</strong>）：你可以设置相同队伍才可以看见玩家的死亡信息</li><li>NAME_TAG_VISIBILITY（<strong>玩家头顶名字可见性</strong>）：你可以设置相同队伍才可以看见头顶名字</li><li>CanSeeFriendlyInvisibles（<strong>是否可以看到自己队伍的人隐身</strong>）</li><li>AllowFriendlyFire（<strong>是否可以友军开火</strong>）<br><del>再也不需要EntityDamageByEntityEvent了!</del></li><li>Color 队伍颜色</li><li>Prefix 队伍前缀，可以直接设置到玩家的NameTag上</li><li>Suffix 队伍后缀，可以直接设置到玩家的NameTag上</li></ul><p><strong>版本变换</strong>：其实在1.13的版本之后Team就更改了一下，主要的就是更改了Prefix和Suffix字符还有DisplayName的长度的限制，因为1.13以后的版本，这些内容改用json来储存</p><p>1.13以前 设置Prefix和Suffix只能在16个字符以内<br>而在1.13以后，设置Prefix和Suffix可以在64个字符以内了<br>并且DisplayName也从32个字符长度增长到128个字符</p><p>此外对于Team就没有更多的API更新了</p><p>那么接下来我们就来看看Team是如何使用的<br>首先我们需要建立一个新的Scoreboard</p><pre><code class="hljs reasonml">Scoreboard teamScoreboard = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bukkit</span>.</span></span>get<span class="hljs-constructor">ScoreboardManager()</span>.get<span class="hljs-constructor">NewScoreboard()</span>;</code></pre><p>之后我们来新建两个队伍，<strong>红队</strong>和<strong>蓝队</strong></p><pre><code class="hljs abnf">Team redTeam = teamScoreboard.registerNewTeam(<span class="hljs-string">"RED"</span>)<span class="hljs-comment">;</span>Team blueTeam = teamScoreboard.registerNewTeam(<span class="hljs-string">"BLUE"</span>)<span class="hljs-comment">;</span></code></pre><p>在上面的代码我们要注意，RED和BLUE其实是队伍的<strong>内部名字，不做显示用</strong></p><p>之后我们来给它设置<strong>别的内容</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">// 设置显示名</span>redTeam.set<span class="hljs-constructor">DisplayName(<span class="hljs-string">"红队"</span>)</span>;blueTeam.set<span class="hljs-constructor">DisplayName(<span class="hljs-string">"蓝队"</span>)</span>;<span class="hljs-comment">// 设置队伍颜色</span>redTeam.set<span class="hljs-constructor">Color(ChatColor.RED)</span>;blueTeam.set<span class="hljs-constructor">Color(ChatColor.BLUE)</span>;<span class="hljs-comment">// 对于自己的队伍进行NameTag显示, 而对其他队伍关闭 -&gt; 制作出类似吃鸡队友的感觉</span><span class="hljs-comment">// 这里的FOR_OTHER_TEAM表示的意思是只对其他队伍 关闭</span>redTeam.set<span class="hljs-constructor">Option(Option.NAME_TAG_VISIBILITY, OptionStatus.FOR_OTHER_TEAMS)</span>;blueTeam.set<span class="hljs-constructor">Option(Option.NAME_TAG_VISIBILITY, OptionStatus.FOR_OTHER_TEAMS)</span>;<span class="hljs-comment">// 对于自己的队伍开启防碰撞体积, 而对其他队伍开启体积碰撞</span><span class="hljs-comment">// 这里的FOR_OWN_TEAM表示的意思是只对本队 关闭</span>redTeam.set<span class="hljs-constructor">Option(Option.COLLISION_RULE, OptionStatus.FOR_OWN_TEAM)</span>;blueTeam.set<span class="hljs-constructor">Option(Option.COLLISION_RULE, OptionStatus.FOR_OWN_TEAM)</span>;<span class="hljs-comment">// 设置同队可看见隐身</span>redTeam.set<span class="hljs-constructor">CanSeeFriendlyInvisibles(<span class="hljs-params">true</span>)</span>;blueTeam.set<span class="hljs-constructor">CanSeeFriendlyInvisibles(<span class="hljs-params">true</span>)</span>;<span class="hljs-comment">// 取消队伤</span>redTeam.set<span class="hljs-constructor">AllowFriendlyFire(<span class="hljs-params">false</span>)</span>;blueTeam.set<span class="hljs-constructor">AllowFriendlyFire(<span class="hljs-params">false</span>)</span>;<span class="hljs-comment">// 设置前缀</span>redTeam.set<span class="hljs-constructor">Prefix(<span class="hljs-string">"§c红队 - "</span>)</span>;blueTeam.set<span class="hljs-constructor">Prefix(<span class="hljs-string">"§8蓝队 - "</span>)</span>;</code></pre><p>之后我们就建立了两个Team，之后我们得需要给他们增加玩家</p><pre><code class="hljs abnf">redTeam.addEntry(<span class="hljs-string">"Zoyn"</span>)<span class="hljs-comment">;</span>blueTeam.addEntry(<span class="hljs-string">"Alex"</span>)<span class="hljs-comment">;</span></code></pre><p>我们在上方的代码中，<br>给<strong>红队</strong>添加了一名队员, Zoyn<br>给<strong>蓝队</strong>添加了一名队员, Alex</p><p>这里要注意的是，给队伍增加队员不是调用 <strong><em>addPlayer(OfflinePlayer player)</em></strong> 这个已经弃用的方法，因为你放在Team里的可以<strong>不只是</strong>Player，所以我们只用放入玩家名就好  </p><p>之后我们给这两个队员设置好Scoreboard（<strong>如果没有做这个操作，可能会导致不显示！</strong>）</p><pre><code class="hljs reasonml">Player zoyn = ?Player alex = ?zoyn.set<span class="hljs-constructor">Scoreboard(<span class="hljs-params">teamScoreboard</span>)</span>;alex.set<span class="hljs-constructor">Scoreboard(<span class="hljs-params">teamScoreboard</span>)</span>;</code></pre><p><strong>完整代码：</strong></p><pre><code class="hljs reasonml">Scoreboard teamScoreboard = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bukkit</span>.</span></span>get<span class="hljs-constructor">ScoreboardManager()</span>.get<span class="hljs-constructor">NewScoreboard()</span>;Team redTeam = teamScoreboard.register<span class="hljs-constructor">NewTeam(<span class="hljs-string">"RED"</span>)</span>;Team blueTeam = teamScoreboard.register<span class="hljs-constructor">NewTeam(<span class="hljs-string">"BLUE"</span>)</span>;<span class="hljs-comment">// 设置显示名</span>redTeam.set<span class="hljs-constructor">DisplayName(<span class="hljs-string">"红队"</span>)</span>;blueTeam.set<span class="hljs-constructor">DisplayName(<span class="hljs-string">"蓝队"</span>)</span>;<span class="hljs-comment">// 设置队伍颜色</span>redTeam.set<span class="hljs-constructor">Color(ChatColor.RED)</span>;blueTeam.set<span class="hljs-constructor">Color(ChatColor.BLUE)</span>;<span class="hljs-comment">// 对于自己的队伍进行NameTag显示, 而对其他队伍关闭 -&gt; 制作出类似吃鸡队友的感觉</span><span class="hljs-comment">// 这里的FOR_OTHER_TEAM表示的意思是只对其他队伍 关闭</span>redTeam.set<span class="hljs-constructor">Option(Option.NAME_TAG_VISIBILITY, OptionStatus.FOR_OTHER_TEAMS)</span>;blueTeam.set<span class="hljs-constructor">Option(Option.NAME_TAG_VISIBILITY, OptionStatus.FOR_OTHER_TEAMS)</span>;<span class="hljs-comment">// 对于自己的队伍开启防碰撞体积, 而对其他队伍开启体积碰撞</span><span class="hljs-comment">// 这里的FOR_OWN_TEAM表示的意思是只对本队 关闭</span>redTeam.set<span class="hljs-constructor">Option(Option.COLLISION_RULE, OptionStatus.FOR_OWN_TEAM)</span>;blueTeam.set<span class="hljs-constructor">Option(Option.COLLISION_RULE, OptionStatus.FOR_OWN_TEAM)</span>;<span class="hljs-comment">// 设置同队可看见隐身</span>redTeam.set<span class="hljs-constructor">CanSeeFriendlyInvisibles(<span class="hljs-params">true</span>)</span>;blueTeam.set<span class="hljs-constructor">CanSeeFriendlyInvisibles(<span class="hljs-params">true</span>)</span>;<span class="hljs-comment">// 取消队伤</span>redTeam.set<span class="hljs-constructor">AllowFriendlyFire(<span class="hljs-params">false</span>)</span>;blueTeam.set<span class="hljs-constructor">AllowFriendlyFire(<span class="hljs-params">false</span>)</span>;<span class="hljs-comment">// 设置前缀</span>redTeam.set<span class="hljs-constructor">Prefix(<span class="hljs-string">"§c红队-"</span>)</span>;blueTeam.set<span class="hljs-constructor">Prefix(<span class="hljs-string">"§9蓝队-"</span>)</span>;redTeam.add<span class="hljs-constructor">Entry(<span class="hljs-string">"Zoyn"</span>)</span>;blueTeam.add<span class="hljs-constructor">Entry(<span class="hljs-string">"Alex"</span>)</span>;Player zoyn = ?Player alex = ?zoyn.set<span class="hljs-constructor">Scoreboard(<span class="hljs-params">teamScoreboard</span>)</span>;alex.set<span class="hljs-constructor">Scoreboard(<span class="hljs-params">teamScoreboard</span>)</span>;</code></pre><p><strong>实际效果：</strong><br>Zoyn视角：<img src="https://upload-images.jianshu.io/upload_images/8109631-0590a76d8f544b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="Zoyn"><br>Alex视角: <img src="https://upload-images.jianshu.io/upload_images/8109631-5ae8184f2033713d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="Alex"></p><p>当他们两者在同一队伍时<img src="https://upload-images.jianshu.io/upload_images/8109631-7eec48266e91b4e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="同一队伍"></p><h4 id="之后为了方便读者测试，我写了一个测试类来给读者测试"><a href="#之后为了方便读者测试，我写了一个测试类来给读者测试" class="headerlink" title="之后为了方便读者测试，我写了一个测试类来给读者测试"></a>之后为了方便读者测试，我写了一个测试类来给读者测试</h4><p>使用方法,<br>1.注册指令 teams （当然你也可以自己改）<br>2.reload之后第一次输入请输入 /teams init 进行队伍初始化<br>3.在指令中的队伍名，只有 RED 和 BLUE </p><p>实例：一个使用Scoreboard#Team的内容来写一个组队系统</p><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.bukkit.Bukkit;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.bukkit.ChatColor;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.bukkit.command.Command;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.bukkit.command.CommandExecutor;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.bukkit.command.CommandSender;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.bukkit.entity.Player;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.bukkit.scoreboard.Scoreboard;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.bukkit.scoreboard.Team;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.bukkit.scoreboard.Team.Option;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.bukkit.scoreboard.Team.OptionStatus;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeamCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandExecutor</span> </span>&#123;<span class="hljs-keyword">private</span> Scoreboard teamScoreboard;@Override<span class="hljs-keyword">public</span> boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) &#123;<span class="hljs-keyword">if</span> (cmd.getName().equalsIgnoreCase(<span class="hljs-string">"teams"</span>)) &#123;<span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">0</span>) &#123;sender.sendMessage(<span class="hljs-string">"/teams init 初始化"</span>);sender.sendMessage(<span class="hljs-string">"/teams list 列出所有队伍"</span>);sender.sendMessage(<span class="hljs-string">"/teams set &lt;玩家名&gt; &lt;队伍名&gt; 将玩家的队伍进行设置"</span>);sender.sendMessage(<span class="hljs-string">"/teams prefix &lt;队伍名&gt; &lt;前缀名&gt; 将玩家的队伍进行前缀的设置"</span>);sender.sendMessage(<span class="hljs-string">"/teams suffix &lt;队伍名&gt; &lt;前缀名&gt; 将玩家的队伍进行前缀的设置"</span>);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">"init"</span>)) &#123;teamScoreboard = Bukkit.getScoreboardManager().getNewScoreboard();Team redTeam = teamScoreboard.registerNewTeam(<span class="hljs-string">"RED"</span>);Team blueTeam = teamScoreboard.registerNewTeam(<span class="hljs-string">"BLUE"</span>);<span class="hljs-comment">// 设置显示名</span>redTeam.setDisplayName(<span class="hljs-string">"红队"</span>);blueTeam.setDisplayName(<span class="hljs-string">"蓝队"</span>);<span class="hljs-comment">// 设置队伍颜色</span>redTeam.setColor(ChatColor.RED);blueTeam.setColor(ChatColor.BLUE);<span class="hljs-comment">// 对于自己的队伍进行NameTag显示, 而对其他队伍关闭 -&gt; 制作出类似吃鸡队友的感觉</span><span class="hljs-comment">// 这里的FOR_OTHER_TEAM表示的意思是只对其他队伍 关闭</span>redTeam.setOption(Option.NAME_TAG_VISIBILITY, OptionStatus.FOR_OTHER_TEAMS);blueTeam.setOption(Option.NAME_TAG_VISIBILITY, OptionStatus.FOR_OTHER_TEAMS);<span class="hljs-comment">// 对于自己的队伍开启防碰撞体积, 而对其他队伍开启体积碰撞</span><span class="hljs-comment">// 这里的FOR_OWN_TEAM表示的意思是只对本队 关闭</span>redTeam.setOption(Option.COLLISION_RULE, OptionStatus.FOR_OWN_TEAM);blueTeam.setOption(Option.COLLISION_RULE, OptionStatus.FOR_OWN_TEAM);<span class="hljs-comment">// 由于只做演示, 所以这里的sender我直接强转得到</span>Player player = (Player) sender;player.setScoreboard(teamScoreboard);sender.sendMessage(<span class="hljs-string">"§a操作成功!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">"list"</span>)) &#123;teamScoreboard.getTeams().forEach(team -&gt; &#123;sender.sendMessage(<span class="hljs-string">"名字: "</span> + team.getName());sender.sendMessage(<span class="hljs-string">"展示名: "</span> + team.getDisplayName());sender.sendMessage(<span class="hljs-string">"已有队员: "</span>);team.getEntries().forEach(player -&gt; &#123;sender.sendMessage(<span class="hljs-string">" - "</span> + player);&#125;);sender.sendMessage(<span class="hljs-string">"====================="</span>);&#125;);sender.sendMessage(<span class="hljs-string">"§a操作成功!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">"set"</span>)) &#123;Player entry = Bukkit.getPlayer(args[<span class="hljs-number">1</span>]);<span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">null</span> || !entry.isOnline()) &#123;sender.sendMessage(<span class="hljs-string">"玩家不在线!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;Team playerTeam = teamScoreboard.getEntryTeam(entry.getName());Team team = teamScoreboard.getTeam(args[<span class="hljs-number">2</span>]);<span class="hljs-keyword">if</span> (playerTeam != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 将玩家离开之前的队伍</span>playerTeam.removeEntry(args[<span class="hljs-number">1</span>]);&#125;<span class="hljs-comment">// 将玩家加入选定的队伍</span>team.addEntry(args[<span class="hljs-number">1</span>]);<span class="hljs-comment">// 对选中的人设置计分板, 不然会导致无法显示的问题</span>entry.setScoreboard(teamScoreboard);sender.sendMessage(<span class="hljs-string">"§a操作成功!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">"prefix"</span>)) &#123;Team team = teamScoreboard.getTeam(args[<span class="hljs-number">1</span>]);team.setPrefix(ChatColor.translateAlternateColorCodes(<span class="hljs-string">'&amp;'</span>, args[<span class="hljs-number">2</span>]));sender.sendMessage(<span class="hljs-string">"§a操作成功!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">"suffix"</span>)) &#123;Team team = teamScoreboard.getTeam(args[<span class="hljs-number">1</span>]);team.setSuffix(ChatColor.translateAlternateColorCodes(<span class="hljs-string">'&amp;'</span>, args[<span class="hljs-number">2</span>]));sender.sendMessage(<span class="hljs-string">"§a操作成功!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><p>这就是BukkitAPI中对 org.bukkit.scoreboard 包的内的所有内容，如果你有相关问题可以回复，一起交流 —— 一个本科人</p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的MC特效(六 | 坐标系的旋转)</title>
    <link href="/2020/03/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E5%85%AD)/"/>
    <url>/2020/03/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E5%85%AD)/</url>
    
    <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h4><ul><li>导读</li><li>Location点的旋转</li><li>坐标系的修正与在玩家背部建立坐标系</li><li>制作简易翅膀<h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4>导读<br>本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)<br>本教程使用的 <strong>PaperSpigot1.12.2-R0.1-SNAPSHOT</strong> 核心<br>在阅读之前请确保你具有<strong>高中数学必修4</strong>和和<strong>Java基础</strong>的知识</li></ul><p>&lt;To初中生&gt;: 如果你是初中的话，别慌，你有趋向的概念就可以读懂本教程(应该吧…)<br>&lt;To高中生&gt;: 如果你还未学到关于上面的那本书，别慌学到了再来看也行233 (雾<br>&lt;To大学生&gt;: 没什么好说的…</p><hr><h4 id="Location点的旋转"><a href="#Location点的旋转" class="headerlink" title="Location点的旋转"></a>Location点的旋转</h4><p>首先我们引入<strong>平面上点围绕另一个点进行旋转</strong>的公式 (数学上)<br>平面中，一个点(x,y)绕任意点(x0,y0)逆时针旋转a度后的坐标</p><pre><code class="hljs lisp">dx = (<span class="hljs-name">x</span> - x0)*cos(<span class="hljs-name">a</span>) - (<span class="hljs-name">y</span> - y0)*sin(<span class="hljs-name">a</span>) + x0 <span class="hljs-comment">;</span>dy = (<span class="hljs-name">x</span> - x0)*sin(<span class="hljs-name">a</span>) + (<span class="hljs-name">y</span> - y0)*cos(<span class="hljs-name">a</span>) + y0 <span class="hljs-comment">;</span></code></pre><p>那么我们写入代码看看是怎么样的</p><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 在二维平面上利用给定的中心点逆时针旋转一个点</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * @param location 待旋转的点</span><span class="hljs-comment"> * @param angle    旋转角度</span><span class="hljs-comment"> * @param point    中心点</span><span class="hljs-comment"> * @return &#123;@link Location&#125;</span><span class="hljs-comment">*/</span>public static Location rotate<span class="hljs-constructor">LocationAboutPoint(Location <span class="hljs-params">location</span>, <span class="hljs-params">double</span> <span class="hljs-params">angle</span>, Location <span class="hljs-params">point</span>)</span> &#123;    double radians = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Radians(<span class="hljs-params">angle</span>)</span>;    double dx = location.get<span class="hljs-constructor">X()</span> - point.get<span class="hljs-constructor">X()</span>;    double dz = location.get<span class="hljs-constructor">Z()</span> - point.get<span class="hljs-constructor">Z()</span>;    double newX = dx<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cos(radians) - dz<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sin(radians) + point.get<span class="hljs-constructor">X()</span>;    double newZ = dz<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cos(radians) + dx<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sin(radians) + point.get<span class="hljs-constructor">Z()</span>;    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Location(<span class="hljs-params">location</span>.<span class="hljs-params">getWorld</span>()</span>, newX, location.get<span class="hljs-constructor">Y()</span>, newZ);&#125;</code></pre><p>总所周知，在mc坐标内，玩家走动的二维平面，其实是<strong>影响x轴和z轴</strong>的内容，所以我们上方的代码就套用x，y</p><h4 id="坐标系的修正与在玩家背部建立坐标系"><a href="#坐标系的修正与在玩家背部建立坐标系" class="headerlink" title="坐标系的修正与在玩家背部建立坐标系"></a>坐标系的修正与在玩家背部建立坐标系</h4><p>在我们之前的教程中，我们都会发现，我们在做一些让特效出现在<strong><em>玩家面前</em></strong>时，会出现<strong>特效</strong>出现在另外一边，这其实就是我们没有经过<strong>玩家朝向的修正</strong>，而发生的情况，比如下面这一张图<br><img src="https://upload-images.jianshu.io/upload_images/8109631-786f3cf0345d9fda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="爱心.png"></p><p>那么我们可以重新建立一个<strong>修正过后的</strong>坐标系，用的方法就是利用Location点的旋转</p><pre><code class="hljs reasonml">import org.bukkit.Location;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 自动修正在平面上的粒子朝向</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * @author Zoyn</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> PlayerFixedCoordinate &#123;<span class="hljs-keyword">private</span> Location zeroDot;<span class="hljs-keyword">private</span> double rotateAngle;public <span class="hljs-constructor">PlayerFixedCoordinate(Location <span class="hljs-params">playerLocation</span>)</span> &#123;<span class="hljs-comment">// 旋转的角度</span>rotateAngle = playerLocation.get<span class="hljs-constructor">Yaw()</span>;zeroDot = playerLocation.clone<span class="hljs-literal">()</span>;zeroDot.set<span class="hljs-constructor">Pitch(0)</span>;<span class="hljs-comment">// 重设仰俯角, 防止出现仰头后旋转角度不正确的问题</span>&#125;public Location get<span class="hljs-constructor">ZeroDot()</span> &#123;return zeroDot;&#125;public Location <span class="hljs-keyword">new</span><span class="hljs-constructor">Location(<span class="hljs-params">double</span> <span class="hljs-params">x</span>, <span class="hljs-params">double</span> <span class="hljs-params">z</span>)</span> &#123;return rotate<span class="hljs-constructor">LocationAboutPoint(<span class="hljs-params">zeroDot</span>.<span class="hljs-params">clone</span>()</span>.add(-x, <span class="hljs-number">0</span>, z), rotateAngle, zeroDot);&#125;        <span class="hljs-comment">/**</span><span class="hljs-comment"> * 在二维平面上利用给定的中心点逆时针旋转一个点</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * @param location 待旋转的点</span><span class="hljs-comment"> * @param angle    旋转角度</span><span class="hljs-comment"> * @param point    中心点</span><span class="hljs-comment"> * @return &#123;@link Location&#125;</span><span class="hljs-comment"> */</span>public static Location rotate<span class="hljs-constructor">LocationAboutPoint(Location <span class="hljs-params">location</span>, <span class="hljs-params">double</span> <span class="hljs-params">angle</span>, Location <span class="hljs-params">point</span>)</span> &#123;double radians = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Radians(<span class="hljs-params">angle</span>)</span>;double dx = location.get<span class="hljs-constructor">X()</span> - point.get<span class="hljs-constructor">X()</span>;double dz = location.get<span class="hljs-constructor">Z()</span> - point.get<span class="hljs-constructor">Z()</span>;double newX = dx<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cos(radians) - dz<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sin(radians) + point.get<span class="hljs-constructor">X()</span>;double newZ = dz<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cos(radians) + dx<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sin(radians) + point.get<span class="hljs-constructor">Z()</span>;return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Location(<span class="hljs-params">location</span>.<span class="hljs-params">getWorld</span>()</span>, newX, location.get<span class="hljs-constructor">Y()</span>, newZ);&#125;&#125;</code></pre><p>首先我们来分析这个类是怎么写的，首先我们要旋转一个点，就需要旋转的角度，那么这时候 <strong><em>location</em></strong> 里的 <strong><em>yaw</em></strong> 就可以帮助我们完成这个工作，所以我在构造器里将 <strong><em>yaw</em></strong> 记录为 <strong><em>rotateAngle</em></strong> </p><p>之后我们看<strong><em>newLocation</em></strong>这个方法，需要填入两个参数分别是 <strong><em>x, y</em></strong> （为了方便理解，我其实直接将其设计为数学上的平面直角坐标系（右手坐标系））</p><p>而我们在看</p><pre><code class="hljs css"><span class="hljs-selector-tag">zeroDot</span><span class="hljs-selector-class">.clone</span>()<span class="hljs-selector-class">.add</span>(<span class="hljs-selector-tag">-x</span>, 0, <span class="hljs-selector-tag">z</span>)</code></pre><p>这行代码, 首先它是 <strong><em>rotateLocationAboutPoint</em></strong> 方法里的<strong>待旋转的点</strong>，那么我们为什么要add呢？<br>因为啊, <strong><em>zeroDot</em></strong> 就是我们坐标系的原点，经过add之后就可以得到新的x，y了，</p><blockquote><p>比如说，zeroDot是(0, 0)，方法填入3, 2, 那么add完之后就得到 (3, 2) 这个点</p></blockquote><p><strong>那么为什么是-x呢？？？</strong><br>因为啊，在Mc中的坐标系是遵循左手坐标系来设计的，所以它的x轴我们要乘以一个-1才能按照我们平常理解的右手坐标系来绘图</p><p>之后我们套用上这个修复过的坐标系来看看效果<br><img src="https://upload-images.jianshu.io/upload_images/8109631-2d53f06a77171156.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="jdfw3.gif"><br>完整代码:</p><pre><code class="hljs routeros">Player player = <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>PlayerFixedCoordinate coordinate = new PlayerFixedCoordinate(player.getLocation());double<span class="hljs-built_in"> radius </span>= 10;<span class="hljs-keyword">for</span> (double t = -1; t &lt;= 1; t += 0.001) &#123;double x =<span class="hljs-built_in"> radius </span>* Math.sin(t) * Math.cos(t) * Math.log(Math.abs(t));double y =<span class="hljs-built_in"> radius </span>* Math.sqrt(Math.abs(t)) * Math.cos(t);Location loc = coordinate.newLocation(x, y);loc.getWorld().spawnParticle(Particle.FIREWORKS_SPARK, loc, 1, 0, 0, 0, 0);&#125;</code></pre><p>下面分享一个<strong><em>PlayerBackCoordinate</em></strong>为了让读者能够举一反三，希望读者能够<strong><em>自行添加 z 轴的变化（思考：z轴的变化在右手坐标系中是如何变化，又应该如何将其转换至MC坐标系内）</em></strong></p><p>绘图思考可以参照这张图：<br><img src="https://upload-images.jianshu.io/upload_images/8109631-9ffc52cc57748de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="PlayerBackCoordinate的思考"></p><pre><code class="hljs reasonml">import org.bukkit.Location;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 将玩家背后转换为一个平面直角坐标系</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * @author Zoyn</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> PlayerBackCoordinate &#123;<span class="hljs-keyword">private</span> Location zeroDot;<span class="hljs-keyword">private</span> double rotateAngle;public <span class="hljs-constructor">PlayerBackCoordinate(Location <span class="hljs-params">playerLocation</span>)</span> &#123;<span class="hljs-comment">// 旋转的角度</span>rotateAngle = playerLocation.get<span class="hljs-constructor">Yaw()</span>;zeroDot = playerLocation.clone<span class="hljs-literal">()</span>;zeroDot.set<span class="hljs-constructor">Pitch(0)</span>; <span class="hljs-comment">// 重设仰俯角</span>zeroDot.add(zeroDot.get<span class="hljs-constructor">Direction()</span>.multiply<span class="hljs-number">(-0.3)</span>); <span class="hljs-comment">// 使原点与玩家有一点点距离</span>&#125;public Location get<span class="hljs-constructor">ZeroDot()</span> &#123;return zeroDot;&#125;public Location <span class="hljs-keyword">new</span><span class="hljs-constructor">Location(<span class="hljs-params">double</span> <span class="hljs-params">x</span>, <span class="hljs-params">double</span> <span class="hljs-params">y</span>)</span> &#123;return rotate<span class="hljs-constructor">LocationAboutPoint(<span class="hljs-params">zeroDot</span>.<span class="hljs-params">clone</span>()</span>.add(-x, y, <span class="hljs-number">0</span>), rotateAngle, zeroDot);&#125;        <span class="hljs-comment">/**</span><span class="hljs-comment"> * 在二维平面上利用给定的中心点逆时针旋转一个点</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * @param location 待旋转的点</span><span class="hljs-comment"> * @param angle    旋转角度</span><span class="hljs-comment"> * @param point    中心点</span><span class="hljs-comment"> * @return &#123;@link Location&#125;</span><span class="hljs-comment"> */</span>public static Location rotate<span class="hljs-constructor">LocationAboutPoint(Location <span class="hljs-params">location</span>, <span class="hljs-params">double</span> <span class="hljs-params">angle</span>, Location <span class="hljs-params">point</span>)</span> &#123;double radians = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Radians(<span class="hljs-params">angle</span>)</span>;double dx = location.get<span class="hljs-constructor">X()</span> - point.get<span class="hljs-constructor">X()</span>;double dz = location.get<span class="hljs-constructor">Z()</span> - point.get<span class="hljs-constructor">Z()</span>;double newX = dx<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cos(radians) - dz<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sin(radians) + point.get<span class="hljs-constructor">X()</span>;double newZ = dz<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cos(radians) + dx<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sin(radians) + point.get<span class="hljs-constructor">Z()</span>;return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Location(<span class="hljs-params">location</span>.<span class="hljs-params">getWorld</span>()</span>, newX, location.get<span class="hljs-constructor">Y()</span>, newZ);&#125;&#125;</code></pre><p>上方代码的使用：实例1：在玩家后背绘制一个圆</p><pre><code class="hljs reasonml">Player player = (Player) sender;PlayerBackCoordinate coordinate = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PlayerBackCoordinate(<span class="hljs-params">player</span>.<span class="hljs-params">getLocation</span>()</span>.add(<span class="hljs-number">0</span>, <span class="hljs-number">1.6</span>D, <span class="hljs-number">0</span>));for (<span class="hljs-built_in">int</span> angle = <span class="hljs-number">0</span>; angle &lt; <span class="hljs-number">360</span>; angle++) &#123;    double radians = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Radians(<span class="hljs-params">angle</span>)</span>;    double x = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cos(radians);    double y = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sin(radians);    Location loc = coordinate.<span class="hljs-keyword">new</span><span class="hljs-constructor">Location(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>)</span>;    loc.get<span class="hljs-constructor">World()</span>.spawn<span class="hljs-constructor">Particle(Particle.FLAME, <span class="hljs-params">loc</span>, 1, 0, 0, 0, 0)</span>;&#125;</code></pre><p>具体效果：<br><img src="https://upload-images.jianshu.io/upload_images/8109631-630f0e23257a8242.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="背后的火圈"></p><h4 id="制作简易翅膀"><a href="#制作简易翅膀" class="headerlink" title="制作简易翅膀"></a>制作简易翅膀</h4><p>不说这么多，直接上代码好吧，用的就是上面的代码</p><pre><code class="hljs angelscript">Player player = (Player) sender;PlayerBackCoordinate coordinate = new PlayerBackCoordinate(player.getLocation().add(<span class="hljs-number">0</span>, <span class="hljs-number">1.5</span>D, <span class="hljs-number">0</span>));<span class="hljs-keyword">for</span> (<span class="hljs-built_in">double</span> angle = <span class="hljs-number">0</span>; angle &lt;= <span class="hljs-number">135</span>; angle++) &#123;    <span class="hljs-built_in">double</span> x = Math.toRadians(angle);    <span class="hljs-built_in">double</span> y = Math.sin(<span class="hljs-number">2</span> * x);    Location loc = coordinate.newLocation(x, y);    loc.getWorld().spawnParticle(Particle.VILLAGER_HAPPY, loc, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">double</span> angle = <span class="hljs-number">-135</span>; angle &lt;= <span class="hljs-number">0</span>; angle++) &#123;    <span class="hljs-built_in">double</span> x = Math.toRadians(angle);    <span class="hljs-built_in">double</span> y = Math.cos((<span class="hljs-number">2</span> * x) + (Math.PI / <span class="hljs-number">2</span>));    Location loc = coordinate.newLocation(x, y);    loc.getWorld().spawnParticle(Particle.VILLAGER_HAPPY, loc, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;coordinate = new PlayerBackCoordinate(player.getLocation().add(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<span class="hljs-built_in">double</span> radius = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">double</span> angle = <span class="hljs-number">0</span>; angle &lt;= <span class="hljs-number">3</span> * <span class="hljs-number">360</span>; angle++) &#123;    <span class="hljs-built_in">double</span> radians = Math.toRadians(angle);    <span class="hljs-built_in">double</span> x = radius * Math.cos(radians);    <span class="hljs-built_in">double</span> y = radius * Math.sin(radians);    Location loc = coordinate.newLocation(x, y);    loc.getWorld().spawnParticle(Particle.FIREWORKS_SPARK, loc, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    radius += <span class="hljs-number">0.001</span>;&#125;</code></pre><p>具体效果:<br><img src="https://upload-images.jianshu.io/upload_images/8109631-f1633dad8c40835b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="函数翅膀"></p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
      <tag>数学</tag>
      
      <tag>MC特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的MC特效(五 | BukkitRunnable与粒子特效)</title>
    <link href="/2019/01/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%BA%94)/"/>
    <url>/2019/01/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h4><ul><li>导读</li><li>BukkitRunnable之逐渐在玩家身旁出现的粒子<h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4>导读<br>本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)<br>本教程使用的 <strong>Spigot1.10.2-R0.1-SNAPSHOT</strong> 核心<br>在阅读之前请确保你具有<strong>高中数学必修4</strong>和和<strong>Java基础</strong>的知识</li></ul><p>&lt;To初中生&gt;: 如果你是初中的话，别慌，你有趋向的概念就可以读懂本教程(应该吧…)<br>&lt;To高中生&gt;: 如果你还未学到关于上面的那本书，别慌学到了再来看也行233 (雾<br>&lt;To大学生&gt;: 没什么好说的…</p><hr><h4 id="BukkitRunnable之逐渐在玩家身旁出现的粒子"><a href="#BukkitRunnable之逐渐在玩家身旁出现的粒子" class="headerlink" title="BukkitRunnable之逐渐在玩家身旁出现的粒子"></a>BukkitRunnable之逐渐在玩家身旁出现的粒子</h4><p>如果读者还不知道这是个什么东西的话，可以通过以下几个地方进行了解<br><a href="https://docs.windit.net/Chinese_BukkitAPI/org/bukkit/scheduler/BukkitRunnable.html" target="_blank" rel="noopener">Bukkit中文文档</a> 或者 <a href="https://bukkit.windit.net/javadoc/org/bukkit/scheduler/BukkitScheduler.html" target="_blank" rel="noopener">这个</a> 还有就是我自己的 <a href="https://www.bilibili.com/video/av20352427/" target="_blank" rel="noopener">视频教程</a></p><p>首先利用BukkitRunnable的Task性质，我们可以制造一个 <strong>粒子特效逐渐渲染</strong> 的效果，而不是像以前那样一下子就渲染完毕，我们来看以下的例子</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CrownEffect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BukkitRunnable</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 玩家</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">Player</span> player;    <span class="hljs-keyword">private</span> double degree = <span class="hljs-number">0</span>;    public <span class="hljs-type">CrownEffect</span>(<span class="hljs-type">Player</span> player) &#123;        <span class="hljs-keyword">this</span>.player = player;    &#125;    <span class="hljs-meta">@Override</span>    public void run() &#123;            &#125;&#125;</code></pre><p>首先我们创建了一个类称之为 CrownEffect 之后我们让它继承于 BukkitRunnable，之后我们需要往run方法里写粒子的出现方式</p><pre><code class="hljs angelscript">@Override<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> run() &#123;    <span class="hljs-comment">// 用于检查玩家是否不在线的情况</span>    <span class="hljs-keyword">if</span> (player == <span class="hljs-literal">null</span> || !player.isOnline()) &#123;        cancel();    &#125;    Location playerLocation = player.getLocation();    <span class="hljs-comment">// 转弧度制</span>    <span class="hljs-built_in">double</span> radians = Math.toRadians(degree);        <span class="hljs-comment">// 这里我写得简单了一点，我们将玩家的坐标克隆之后直接进行x, y, z的变换</span>    <span class="hljs-comment">// 不难看出，我们这里是想建立一个 0.3 为半径的圆，作为我们想要实现的皇冠</span>    Location playEffectLocation = playerLocation.clone().add(<span class="hljs-number">0.3</span> * Math.cos(radians), <span class="hljs-number">2</span>D, <span class="hljs-number">0.3</span> * Math.sin(radians));    <span class="hljs-comment">// 粒子播放，这里我使用了类库</span>    ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.ORANGE), playEffectLocation, <span class="hljs-number">50</span>);    <span class="hljs-comment">// 我们只需要degree在0~360度内即可</span>    <span class="hljs-keyword">if</span> (degree &gt;= <span class="hljs-number">360</span>) &#123;        degree = <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;       <span class="hljs-comment">// 这里其实就是修改了步长为20 degree</span>       degree += <span class="hljs-number">20</span>;    &#125;&#125;</code></pre><p>通过上方的代码，相信你已经可以理解我们所要实现的内容了，之后我们对这个类进行进一步的完善</p><pre><code class="hljs angelscript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 王冠特效</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @author Zoyn</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">CrownEffect</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">BukkitRunnable</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 玩家</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Player player;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> degree = <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> CrownEffect(Player player) &#123;        <span class="hljs-keyword">this</span>.player = player;    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> run() &#123;        <span class="hljs-keyword">if</span> (player == <span class="hljs-literal">null</span> || !player.isOnline()) &#123;            cancel();        &#125;        Location playerLocation = player.getLocation();        <span class="hljs-built_in">double</span> radians = Math.toRadians(degree);        Location playEffectLocation = playerLocation.clone().add(<span class="hljs-number">0.3</span> * Math.cos(radians), <span class="hljs-number">2</span>D, <span class="hljs-number">0.3</span> * Math.sin(radians));        ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.ORANGE), playEffectLocation, <span class="hljs-number">50</span>);        <span class="hljs-keyword">if</span> (degree &gt;= <span class="hljs-number">360</span>) &#123;            degree = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            degree += <span class="hljs-number">20</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 开启特效的方法</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> startEffect() &#123;        runTaskTimer(主类的实例, <span class="hljs-number">0</span>L, <span class="hljs-number">1</span>L);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 关闭特效的方法</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> stopEffect() &#123;        cancel();    &#125;&#125;</code></pre><p>调用方法</p><pre><code class="hljs reasonml">CrownEffect crownEffect = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CrownEffect(<span class="hljs-params">player</span>)</span>;crownEffect.start<span class="hljs-constructor">Effect()</span>;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/8109631-f53c0c5e9fae7f1a.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="王冠"></p><h6 id="如果我们将run内的绘制算法更改一下会怎样呢？"><a href="#如果我们将run内的绘制算法更改一下会怎样呢？" class="headerlink" title="如果我们将run内的绘制算法更改一下会怎样呢？"></a>如果我们将run内的绘制算法更改一下会怎样呢？</h6><pre><code class="hljs processing">@Override<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;    <span class="hljs-comment">// 依然还是要判断玩家</span>    <span class="hljs-keyword">if</span> (player == <span class="hljs-keyword">null</span> || !player.isOnline()) &#123;        cancel();    &#125;    Location playerLocation = player.getLocation().<span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>D, <span class="hljs-number">0</span>);    <span class="hljs-keyword">double</span> <span class="hljs-built_in">radians</span> = Math.toRadians(degree);    <span class="hljs-keyword">double</span> x = 半径 * Math.<span class="hljs-built_in">cos</span>(<span class="hljs-built_in">radians</span>);    <span class="hljs-keyword">double</span> y = Math.<span class="hljs-built_in">sin</span>(<span class="hljs-built_in">radians</span>);    <span class="hljs-keyword">double</span> z = 半径 * Math.<span class="hljs-built_in">sin</span>(<span class="hljs-built_in">radians</span>);    Location playEffectLocation = playerLocation.clone().<span class="hljs-built_in">add</span>(x, y, z);    ParticleEffect.REDSTONE.display(<span class="hljs-keyword">new</span> ParticleEffect.OrdinaryColor(Color.RED), playEffectLocation, <span class="hljs-number">50</span>);    <span class="hljs-keyword">if</span> (degree &gt;= <span class="hljs-number">360</span>) &#123;        degree = <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        degree += <span class="hljs-number">10</span>;    &#125;&#125;</code></pre><p>那么你就可以看到这样的效果<br><img src="https://upload-images.jianshu.io/upload_images/8109631-071525f1c388ab37.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="我也不懂叫什么的特效"></p><p>以上便是BukkitRunnable与粒子特效的小技巧，下面放送一个自己利用前几节课的知识加上本节的知识所写的一个特效</p><pre><code class="hljs angelscript"><span class="hljs-comment">// 会旋转的DNA</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">RotatableDNA</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">BukkitRunnable</span> &#123;    <span class="hljs-comment">// 原点</span>    <span class="hljs-keyword">private</span> Location location;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> yaw = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> y = <span class="hljs-number">0</span>D;    <span class="hljs-keyword">public</span> RotatableDNA(Location location) &#123;        <span class="hljs-keyword">this</span>.location = location.clone();    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> run() &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">double</span> degree = <span class="hljs-number">0</span>, angle = <span class="hljs-number">180</span>; degree &lt; <span class="hljs-number">480</span>; degree += <span class="hljs-number">5</span>, angle += <span class="hljs-number">5</span>) &#123;            <span class="hljs-comment">// 第一条</span>            <span class="hljs-built_in">double</span> radians = Math.toRadians(degree);            <span class="hljs-built_in">double</span> x = Math.cos(radians);            <span class="hljs-built_in">double</span> z = Math.sin(radians);            Vector vector = VectorUtils.getVector(location, location.clone().add(x, y, z));            Vector rotatedVector = VectorUtils.rotateVector(vector, yaw, <span class="hljs-number">0</span>);            location.add(rotatedVector);            ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.RED), location, <span class="hljs-number">50</span>);            location.subtract(rotatedVector);            <span class="hljs-comment">// 第二条</span>            <span class="hljs-built_in">double</span> radians2 = Math.toRadians(angle);            <span class="hljs-built_in">double</span> x2 = Math.cos(radians2);            <span class="hljs-built_in">double</span> z2 = Math.sin(radians2);            Vector vector2 = VectorUtils.getVector(location, location.clone().add(x2, y, z2));            Vector rotatedVector2 = VectorUtils.rotateVector(vector2, yaw, <span class="hljs-number">0</span>);            location.add(rotatedVector2);            ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.RED), location, <span class="hljs-number">20</span>);            location.subtract(rotatedVector2);            <span class="hljs-comment">//中间连线</span>            <span class="hljs-keyword">if</span> (degree % <span class="hljs-number">30</span> == <span class="hljs-number">0</span>) &#123;                Location pointA = location.clone().add(rotatedVector);                Location pointB = location.clone().add(rotatedVector2);                EntityNBT.buildLine(pointA, pointB);            &#125;            y += <span class="hljs-number">0.1</span>;        &#125;        <span class="hljs-comment">// 将yaw设定在0~360之间进行循环</span>        <span class="hljs-keyword">if</span> (yaw &gt;= <span class="hljs-number">360</span>) &#123;            yaw = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            yaw += <span class="hljs-number">5</span>;        &#125;        y = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> startEffect() &#123;        runTaskTimer(主类实例, <span class="hljs-number">0</span>L, <span class="hljs-number">1</span>L);    &#125;&#125;</code></pre><p>调用方法</p><pre><code class="hljs reasonml">RotatableDNA rotatableDNA = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RotatableDNA(<span class="hljs-params">location</span>)</span>;rotatableDNA.start<span class="hljs-constructor">Effect()</span>;</code></pre><p>具体效果<br><img src="https://upload-images.jianshu.io/upload_images/8109631-8985ef792a6522cb.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="period为3时"></p><p><img src="https://upload-images.jianshu.io/upload_images/8109631-acfedba833aea5fd.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="period为1时"></p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
      <tag>数学</tag>
      
      <tag>MC特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的MC特效(四 | Sin与Cos函数在Y轴上的体现)</title>
    <link href="/2019/01/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E5%9B%9B)/"/>
    <url>/2019/01/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h4><ul><li>导读</li><li>龙卷风</li><li>环绕在玩家身旁的粒子</li><li>DNA双螺旋结构<h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4>导读<br>本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)<br>本教程使用的 <strong>Spigot1.10.2-R0.1-SNAPSHOT</strong> 核心<br>在阅读之前请确保你具有<strong>高中数学必修4</strong>和和<strong>Java基础</strong>的知识</li></ul><p>&lt;To初中生&gt;: 如果你是初中的话，别慌，你有趋向的概念就可以读懂本教程(应该吧…)<br>&lt;To高中生&gt;: 如果你还未学到关于上面的那本书，别慌学到了再来看也行233 (雾<br>&lt;To大学生&gt;: 没什么好说的…</p><hr><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>首先我们来看一张图<br><img src="https://upload-images.jianshu.io/upload_images/8109631-883bd87e3ee0eaab.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="正弦余弦的空间展示"></p><p>在上图我们可以看到，Sin和Cos的图像，在Y轴上的体现就是一个螺旋，那么我们如果放到MC里要如何实现呢？</p><p>我们来看下方的代码</p><pre><code class="hljs glsl"><span class="hljs-type">double</span> radius = <span class="hljs-number">1</span>D;<span class="hljs-type">double</span> y = <span class="hljs-number">0</span>D;<span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> degree = <span class="hljs-number">0</span>; degree &lt; <span class="hljs-number">360</span> * <span class="hljs-number">2</span>; degree++) &#123;    <span class="hljs-type">double</span> <span class="hljs-built_in">radians</span> = Math.toRadians(degree);    <span class="hljs-type">double</span> x = radius * Math.<span class="hljs-built_in">cos</span>(<span class="hljs-built_in">radians</span>);    <span class="hljs-type">double</span> z = radius * Math.<span class="hljs-built_in">sin</span>(<span class="hljs-built_in">radians</span>);    <span class="hljs-keyword">location</span>.add(x, y, z);    <span class="hljs-comment">// 这里播放粒子使用了类库 ParticleEffect</span>    ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.RED), <span class="hljs-keyword">location</span>, <span class="hljs-number">50</span>);    <span class="hljs-keyword">location</span>.subtract(x, y, z);    y += <span class="hljs-number">0.005</span>;&#125;</code></pre><p>看过MC特效第一章的都可以发现这其实就是一个<strong>利用参数方程绘制圆的代码</strong>，那么不同与第一章的，我<strong>在Y轴上</strong>额外加了个参数，也就是代码中的y，这个y我让其在<strong>每次循环中增加0.005个单位</strong>，那么就可以<strong>将每次粒子绘制时比之前多一个y的单位，进而形成螺旋的效果</strong></p><h4 id="龙卷风"><a href="#龙卷风" class="headerlink" title="龙卷风"></a>龙卷风</h4><p>有了前面的基础，我们可以来思考，龙卷风要怎么弄？<br>首先我们来看圆的参数方程<br><strong>x = r * cosθ</strong><br><strong>y = r * sinθ</strong><br>上方的r其实就是<strong>圆的半径</strong>，那么我们可以这么分析，如果<strong>将r变成一个可变参数</strong>，并且让它<strong>逐渐发散</strong>的话，那么不就是一个<strong>龙卷风</strong>的效果么？我们来看下方的代码</p><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> (double<span class="hljs-built_in"> radius </span>= 0, y = 0, degree = 0; degree &lt; 360 * 4; degree++, y += 0.01,<span class="hljs-built_in"> radius </span>+= 0.01) &#123;    double radians = Math.toRadians(degree);    double x =<span class="hljs-built_in"> radius </span>* Math.cos(radians);    double z =<span class="hljs-built_in"> radius </span>* Math.sin(radians);    loc.<span class="hljs-builtin-name">add</span>(x, y, z);    ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.RED), loc, 50);    loc.subtract(x, y, z);&#125;</code></pre><p>首先我们定义了三个变量<strong>radius y degree</strong>这三个变量分别是 <strong>半径  y轴 角度</strong>其实根据代码，不难看出，每次y单位都是自加0.01，半径也是0.01，角度就是自加1，最终的效果就会是这样的<br><img src="https://upload-images.jianshu.io/upload_images/8109631-760a3a3b19c028db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="龙卷风"></p><h4 id="环绕在玩家身旁的粒子"><a href="#环绕在玩家身旁的粒子" class="headerlink" title="环绕在玩家身旁的粒子"></a>环绕在玩家身旁的粒子</h4><p>那么在上方的<strong>龙卷风例子</strong>中，我们将y轴所加的数值设置为<strong>一个定值0.01</strong>那么我们如果<strong>将y轴所加的数值用个函数来表示</strong>会怎样呢？我们来看下方的代码</p><pre><code class="hljs routeros">double<span class="hljs-built_in"> radius </span>= 1D;<span class="hljs-keyword">for</span> (int degree = 0; degree &lt; 360; degree++) &#123;        double radians = Math.toRadians(degree);        double x =<span class="hljs-built_in"> radius </span>* Math.cos(radians);        double z =<span class="hljs-built_in"> radius </span>* Math.sin(radians);        double y = Math.sin(radians);        loc.<span class="hljs-builtin-name">add</span>(x, y, z);        ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.RED), loc, 50);        loc.subtract(x, y, z);&#125;<span class="hljs-keyword">for</span> (int degree = 0; degree &lt; 360; degree++) &#123;    double radians = Math.toRadians(degree);    double x =<span class="hljs-built_in"> radius </span>* Math.cos(radians);    double z =<span class="hljs-built_in"> radius </span>* Math.sin(radians);    double y = Math.sin(radians);    loc.<span class="hljs-builtin-name">add</span>(-x, y, -z);    ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.BLUE), loc, 50);    loc.subtract(-x, y, -z);&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/8109631-be16bdb0651a2308.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="围绕粒子"></p><p>因为sin函数的特殊性，我们的y就<strong>被限制在1~-1之间</strong>移动了，所以就可以出现这么好看的一次特效了，<strong>那么蓝色的那条我们在x和z参数乘以个-1就可以达到目的</strong></p><h4 id="DNA双螺旋结构"><a href="#DNA双螺旋结构" class="headerlink" title="DNA双螺旋结构"></a>DNA双螺旋结构</h4><p>这个其实非常的简单，我直接给出代码吧</p><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> buildDNA(<span class="hljs-keyword">Location</span> <span class="hljs-keyword">location</span>) &#123;    <span class="hljs-type">double</span> radius = <span class="hljs-number">1</span>D;    <span class="hljs-type">double</span> y = <span class="hljs-number">0</span>D;    <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> degree = <span class="hljs-number">0</span>, angle = <span class="hljs-number">180</span>; degree &lt; <span class="hljs-number">720</span>; degree++, angle++) &#123;        // 第一条        <span class="hljs-type">double</span> radians = Math.toRadians(degree);        <span class="hljs-type">double</span> x = radius * Math.cos(radians);        <span class="hljs-type">double</span> z = radius * Math.sin(radians);        <span class="hljs-keyword">location</span>.<span class="hljs-keyword">add</span>(x, y, z);        ParticleEffect.REDSTONE.display(<span class="hljs-built_in">new</span> ParticleEffect.OrdinaryColor(Color.RED), <span class="hljs-keyword">location</span>, <span class="hljs-number">50</span>);        <span class="hljs-keyword">location</span>.subtract(x, y, z);        // 第二条        <span class="hljs-type">double</span> radians2 = Math.toRadians(angle);        <span class="hljs-type">double</span> x2 = radius * Math.cos(radians2);        <span class="hljs-type">double</span> z2 = radius * Math.sin(radians2);        <span class="hljs-keyword">location</span>.<span class="hljs-keyword">add</span>(x2, y, z2);        ParticleEffect.REDSTONE.display(<span class="hljs-built_in">new</span> ParticleEffect.OrdinaryColor(Color.RED), <span class="hljs-keyword">location</span>, <span class="hljs-number">50</span>);        <span class="hljs-keyword">location</span>.subtract(x2, y, z2);        // 中间连线，这里我打算是在可以被<span class="hljs-number">30</span>整除时就进行画线        <span class="hljs-keyword">if</span> (degree % <span class="hljs-number">30</span> == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">Location</span> pointA = <span class="hljs-keyword">location</span>.clone().<span class="hljs-keyword">add</span>(x, y, z);            <span class="hljs-keyword">Location</span> pointB = <span class="hljs-keyword">location</span>.clone().<span class="hljs-keyword">add</span>(x2, y, z2);            buildLine(pointA, pointB);        &#125;        y += <span class="hljs-number">0.02</span>;   &#125;&#125;<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> buildLine(<span class="hljs-keyword">Location</span> locA, <span class="hljs-keyword">Location</span> locB) &#123;    Vector vectorAB = locB.clone().subtract(locA).toVector();    buildLine(locA, vectorAB);&#125;<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> buildLine(<span class="hljs-keyword">Location</span> locA, Vector vector) &#123;    Vector <span class="hljs-keyword">temp</span> = vector.clone();    <span class="hljs-type">double</span> vectorLength = <span class="hljs-keyword">temp</span>.length();    <span class="hljs-keyword">temp</span>.normalize();    <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">0</span>; i &lt; vectorLength; i += <span class="hljs-number">0.1</span>) &#123;        Vector vectorX = <span class="hljs-keyword">temp</span>.clone().multiply(i);        locA.<span class="hljs-keyword">add</span>(vectorX);        ParticleEffect.REDSTONE.display(<span class="hljs-built_in">new</span> ParticleEffect.OrdinaryColor(Color.BLUE), locA, <span class="hljs-number">50</span>);        locA.subtract(vectorX);    &#125;&#125;</code></pre><p>那么出来的效果就是这样的<br><img src="https://upload-images.jianshu.io/upload_images/8109631-1810407a8bef08b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="DNA"></p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
      <tag>数学</tag>
      
      <tag>MC特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的MC特效(三 | 向量的旋转)</title>
    <link href="/2019/01/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%B8%89)/"/>
    <url>/2019/01/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h4><ul><li>导读</li><li>Yaw，Pitch，Roll与向量的旋转</li><li>利用向量旋转一个圆</li></ul><hr><h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4><p>导读<br>本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)<br>本教程使用的 <strong>Spigot1.10.2-R0.1-SNAPSHOT</strong> 核心<br>在阅读之前请确保你具有<strong>高中数学必修4</strong>和<strong>选修4-4坐标系与参数方程</strong>和<strong>Java基础</strong>的知识<br>(没有我不会解释的)</p><blockquote><p>高三时间有限，我就不解释了，请读者见谅! —— 作者 2019/1/12</p></blockquote><p>&lt;To初中生&gt;: 如果你是初中的话，别慌，你有趋向的概念就可以读懂本教程(应该吧…)<br>&lt;To高中生&gt;: 如果你还未学到关于上面的那本书，别慌学到了再来看也行233 (雾<br>&lt;To大学生&gt;: 没什么好说的…</p><hr><h4 id="Yaw，Pitch，Roll与向量的旋转"><a href="#Yaw，Pitch，Roll与向量的旋转" class="headerlink" title="Yaw，Pitch，Roll与向量的旋转"></a>Yaw，Pitch，Roll与向量的旋转</h4><p>这次我们来讲讲一些概念上的东西，在Minecraft中除了X, Y, Z之外Location还有两个量一个是Yaw一个是Pitch，这两个东西在学术上被称为<strong>欧拉角</strong>(飞机姿态角)<br>怎么理解这三个内容呢？</p><p><strong>Yaw</strong>: 我们 <strong>水平旋转</strong> 我们的头，也就是左右转头，这就是一次Yaw转动</p><p><strong>Pitch</strong>: 我们 <strong>上下旋转</strong> 我们的头，也就是上下点头，这就是一次Pitch转动</p><p><em>Roll: 这个东西在Minecraft里面没有，但是我也讲一下，大家都玩过绝地求生吧，里面的人物QE摇头时就是一次Roll转动</em></p><p><a href="https://jingyan.baidu.com/article/0bc808fc2c0e851bd485b9ce.html" target="_blank" rel="noopener">看不懂我说的可以看别的有图的</a></p><p>那么它们跟我们的向量旋转有什么关系呢？其实在Minecraft中，我们利用Yaw和Pitch就可以描述出一个Vector向量，如我们看如下的图<br><img src="https://upload-images.jianshu.io/upload_images/8109631-145349f2b1b9e144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="Minecraft Yaw 图.png"></p><p>在Minecraft当中，Yaw为0时，它表示的就是Z轴正半轴的方向，为-90°时则表示X轴正半轴的方向</p><h6 id="Pitch就是你的Steve上下看时的方向，看向天空时最大值是-90，看向地板时最大值是90，正视时就是0"><a href="#Pitch就是你的Steve上下看时的方向，看向天空时最大值是-90，看向地板时最大值是90，正视时就是0" class="headerlink" title="Pitch就是你的Steve上下看时的方向，看向天空时最大值是-90，看向地板时最大值是90，正视时就是0"></a>Pitch就是你的Steve上下看时的方向，看向天空时最大值是-90，看向地板时最大值是90，正视时就是0</h6><hr><p>概念的东西都讲完了，我们来谈谈向量的旋转，那么在数学上的话，平面向量的旋转是有直接的公式套用，或者利用矩阵也可以达到目的，<a href="https://blog.csdn.net/hjq376247328/article/details/45113563" target="_blank" rel="noopener">点我看相关资料</a></p><p>那么通过上面的资料，我们就可以得到三个方法</p><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 将一个向量围绕X轴旋转angle个角度</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param v     向量</span><span class="hljs-comment"> * @param angle 角度</span><span class="hljs-comment"> * @return &#123;@link Vector&#125;</span><span class="hljs-comment"> */</span>public static Vector rotate<span class="hljs-constructor">AroundAxisX(Vector <span class="hljs-params">v</span>, <span class="hljs-params">double</span> <span class="hljs-params">angle</span>)</span> &#123;    angle = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Radians(<span class="hljs-params">angle</span>)</span>;    double y, z, cos, sin;    cos = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cos(angle);    sin = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sin(angle);    y = v.get<span class="hljs-constructor">Y()</span><span class="hljs-operator"> * </span>cos - v.get<span class="hljs-constructor">Z()</span><span class="hljs-operator"> * </span>sin;    z = v.get<span class="hljs-constructor">Y()</span><span class="hljs-operator"> * </span>sin + v.get<span class="hljs-constructor">Z()</span><span class="hljs-operator"> * </span>cos;    return v.set<span class="hljs-constructor">Y(<span class="hljs-params">y</span>)</span>.set<span class="hljs-constructor">Z(<span class="hljs-params">z</span>)</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 将一个向量围绕Y轴旋转angle个角度</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param v     向量</span><span class="hljs-comment"> * @param angle 角度</span><span class="hljs-comment"> * @return &#123;@link Vector&#125;</span><span class="hljs-comment"> */</span>public static Vector rotate<span class="hljs-constructor">AroundAxisY(Vector <span class="hljs-params">v</span>, <span class="hljs-params">double</span> <span class="hljs-params">angle</span>)</span> &#123;    angle = -angle;    angle = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Radians(<span class="hljs-params">angle</span>)</span>;    double x, z, cos, sin;    cos = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cos(angle);    sin = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sin(angle);    x = v.get<span class="hljs-constructor">X()</span><span class="hljs-operator"> * </span>cos + v.get<span class="hljs-constructor">Z()</span><span class="hljs-operator"> * </span>sin;    z = v.get<span class="hljs-constructor">X()</span><span class="hljs-operator"> * </span>-sin + v.get<span class="hljs-constructor">Z()</span><span class="hljs-operator"> * </span>cos;    return v.set<span class="hljs-constructor">X(<span class="hljs-params">x</span>)</span>.set<span class="hljs-constructor">Z(<span class="hljs-params">z</span>)</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 将一个向量围绕Z轴旋转angle个角度</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param v     向量</span><span class="hljs-comment"> * @param angle 角度</span><span class="hljs-comment"> * @return &#123;@link Vector&#125;</span><span class="hljs-comment"> */</span>public static Vector rotate<span class="hljs-constructor">AroundAxisZ(Vector <span class="hljs-params">v</span>, <span class="hljs-params">double</span> <span class="hljs-params">angle</span>)</span> &#123;    angle = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Radians(<span class="hljs-params">angle</span>)</span>;    double x, y, cos, sin;    cos = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cos(angle);    sin = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sin(angle);    x = v.get<span class="hljs-constructor">X()</span><span class="hljs-operator"> * </span>cos - v.get<span class="hljs-constructor">Y()</span><span class="hljs-operator"> * </span>sin;    y = v.get<span class="hljs-constructor">X()</span><span class="hljs-operator"> * </span>sin + v.get<span class="hljs-constructor">Y()</span><span class="hljs-operator"> * </span>cos;    return v.set<span class="hljs-constructor">X(<span class="hljs-params">x</span>)</span>.set<span class="hljs-constructor">Y(<span class="hljs-params">y</span>)</span>;&#125;</code></pre><p>那么如果我们想用Yaw和Pitch来旋转向量应该怎么做呢？这里我直接给出方法，来自开源项目<a href="https://github.com/Slikey/EffectLib" target="_blank" rel="noopener">EffectLib</a>里的<a href="https://github.com/Slikey/EffectLib/blob/master/src/main/java/de/slikey/effectlib/util/VectorUtils.java" target="_blank" rel="noopener">VectorUtils.java</a></p><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment"> * This handles non-unit vectors, with yaw and pitch instead of X,Y,Z angles.</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * Thanks to SexyToad!</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * 将一个非单位向量使用yaw和pitch来代替X, Y, Z的角旋转方式</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param v            向量</span><span class="hljs-comment"> * @param yawDegrees   yaw的角度</span><span class="hljs-comment"> * @param pitchDegrees pitch的角度</span><span class="hljs-comment"> * @return</span><span class="hljs-comment"> */</span>public static final Vector rotate<span class="hljs-constructor">Vector(Vector <span class="hljs-params">v</span>, <span class="hljs-params">float</span> <span class="hljs-params">yawDegrees</span>, <span class="hljs-params">float</span> <span class="hljs-params">pitchDegrees</span>)</span> &#123;    double yaw = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Radians(-1 <span class="hljs-operator">*</span> (<span class="hljs-params">yawDegrees</span> + 90)</span>);    double pitch = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Radians(-<span class="hljs-params">pitchDegrees</span>)</span>;    double cosYaw = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cos(yaw);    double cosPitch = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cos(pitch);    double sinYaw = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sin(yaw);    double sinPitch = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sin(pitch);    double initialX, initialY, initialZ;    double x, y, z;    <span class="hljs-comment">// Z_Axis rotation (Pitch)</span>    initialX = v.get<span class="hljs-constructor">X()</span>;    initialY = v.get<span class="hljs-constructor">Y()</span>;    x = initialX<span class="hljs-operator"> * </span>cosPitch - initialY<span class="hljs-operator"> * </span>sinPitch;    y = initialX<span class="hljs-operator"> * </span>sinPitch + initialY<span class="hljs-operator"> * </span>cosPitch;    <span class="hljs-comment">// Y_Axis rotation (Yaw)</span>    initialZ = v.get<span class="hljs-constructor">Z()</span>;    initialX = x;    z = initialZ<span class="hljs-operator"> * </span>cosYaw - initialX<span class="hljs-operator"> * </span>sinYaw;    x = initialZ<span class="hljs-operator"> * </span>sinYaw + initialX<span class="hljs-operator"> * </span>cosYaw;    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vector(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>, <span class="hljs-params">z</span>)</span>;&#125;</code></pre><h5 id="具体的证明过程我这里就不阐述了，请读者自行解决吧…"><a href="#具体的证明过程我这里就不阐述了，请读者自行解决吧…" class="headerlink" title="具体的证明过程我这里就不阐述了，请读者自行解决吧…"></a>具体的证明过程我这里就不阐述了，请读者自行解决吧…</h5><p>那么有了上面的基础我们就可以来做一个简单向量旋转的特效</p><h4 id="利用向量旋转一个圆"><a href="#利用向量旋转一个圆" class="headerlink" title="利用向量旋转一个圆"></a>利用向量旋转一个圆</h4><p>首先我们需要做个分析<br>如果我们要用向量制作一个围绕Y轴的圆可以怎么做呢？<br>我们看下方的代码</p><pre><code class="hljs reasonml">public void create<span class="hljs-constructor">ACircleWithVector(Location <span class="hljs-params">loc</span>)</span> &#123;    double radius = <span class="hljs-number">1</span>D;    <span class="hljs-comment">// 我们直接在X轴正半轴上加一个单位, 用来制作我们的第一个向量</span>    Vector originalVector = get<span class="hljs-constructor">Vector(<span class="hljs-params">loc</span>, <span class="hljs-params">loc</span>.<span class="hljs-params">clone</span>()</span>.add(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));    originalVector.multiply(radius); <span class="hljs-comment">// 圆的半径长度</span>    for (<span class="hljs-built_in">int</span> degree = <span class="hljs-number">0</span>; degree &lt; <span class="hljs-number">360</span>; degree++) &#123;        <span class="hljs-comment">// 我们将向量进行旋转</span>        Vector vector = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">VectorUtils</span>.</span></span>rotate<span class="hljs-constructor">AroundAxisY(<span class="hljs-params">originalVector</span>, <span class="hljs-params">degree</span>)</span>;        loc.add(vector);        loc.get<span class="hljs-constructor">World()</span>.spawn<span class="hljs-constructor">Particle(Particle.FLAME, <span class="hljs-params">loc</span>, 0)</span>;        loc.subtract(vector);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 取第一个坐标到第二个坐标的向量</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param firstLocation  坐标1</span><span class="hljs-comment"> * @param secondLocation 坐标2</span><span class="hljs-comment"> * @return &#123;@link Vector&#125;</span><span class="hljs-comment"> */</span>public static Vector get<span class="hljs-constructor">Vector(Location <span class="hljs-params">firstLocation</span>, Location <span class="hljs-params">secondLocation</span>)</span> &#123;    return secondLocation.clone<span class="hljs-literal">()</span>.subtract(firstLocation).<span class="hljs-keyword">to</span><span class="hljs-constructor">Vector()</span>;&#125;</code></pre><p>首先我们看这行代码</p><pre><code class="hljs Vector">这行要怎么理解呢？我们看下方的图来理解一下![向量OA](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;8109631-370b6d67e0caf43d.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)首先我们在loc的X轴上增加了一个单位也就是图中的**A点**，那么我们利用**终点减起点**来得到向量OA(看不懂的去复习**MC特效二**)，那么这个向量OA我们将做为我们的***待旋转向量***之后我们进入循环，我们**假设**degree是2&#96;&#96;&#96;Vector vector &#x3D; VectorUtils.rotateAroundAxisY(originalVector, 2);</code></pre><p>那么我们调用该方法即可得到<strong>绕Y轴逆时针旋转2个角度</strong>后的向量</p><p>之后就是<strong>坐标加向量，绘制粒子，坐标减去向量保持坐标不变</strong>等一系列通法<br>最终的效果就是这样啦<br><img src="https://upload-images.jianshu.io/upload_images/8109631-f1492c926c67a7e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="绕Y轴旋转"></p><hr><p>那么我们如果想制作一个类似物品掉落时，然后物品围绕Y轴旋转的那种效果，我们又要怎么做呢？这里我们就要利用到Yaw和Pitch</p><p>首先我们这里新建一个类用于旋转圆特效的实现，并且让它继承BukkitRunnable，当然Runnable也是可以的</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RotatableCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BukkitRunnable</span> </span>&#123;    <span class="hljs-comment">// 原点</span>    <span class="hljs-keyword">private</span> Location location;    <span class="hljs-comment">// X轴上的单位向量</span>    <span class="hljs-keyword">private</span> Vector originalVector;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> yaw = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius = <span class="hljs-number">1</span>D;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RotatableCircle</span><span class="hljs-params">(Location location)</span> </span>&#123;        <span class="hljs-keyword">this</span>.location = location.clone();        <span class="hljs-comment">// getVector() 方法是上面已经发过的一个方法，目的是构造一个向量OA</span>        originalVector = getVector(location, location.clone().add(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 取第一个坐标到第二个坐标的向量</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> firstLocation  坐标1</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> secondLocation 坐标2</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@link</span> Vector&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector <span class="hljs-title">getVector</span><span class="hljs-params">(Location firstLocation, Location secondLocation)</span> </span>&#123;        <span class="hljs-keyword">return</span> secondLocation.clone().subtract(firstLocation).toVector();    &#125;&#125;</code></pre><p>从上方的代码我们先简单的需要几个基本量，<strong>待旋转向量和原点</strong>即可，之后yaw和radius分别是yaw和圆的半径</p><p><strong>在构造函数里，我们将传入的location参数进行克隆以防原location的变动</strong><br>之后我们依然<strong>做一个向量OA，当作待旋转向量</strong></p><p>之后我们进行几何分析，看下图<br><img src="https://upload-images.jianshu.io/upload_images/8109631-370b6d67e0caf43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="向量OA"></p><p>首先这是一个向量OA，如果我们想让它旋转1个yaw单位可以使用以下方法</p><pre><code class="hljs Vector">![旋转θ个yaw角](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;8109631-0e200fe6aa94c495.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)那么这就是旋转一个θ yaw角，那么pitch角要怎么旋转呢？![旋转θ个pitch角](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;8109631-fc7c340b7847a6fd.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)根据上方的图我们将向量OA旋转θ个角之后得到了向量OB，那么我们就可以这么写我们的代码</code></pre><p>// 请注意第三个参数 θ 是角度<br>Vector vector = VectorUtils.rotateVector(originalVector, 0, θ)</p><pre><code class="hljs plain">那么有了上面的铺垫我们可以这么写我们的RotatableCircle</code></pre><p>public class RotatableCircle extends BukkitRunnable {</p><pre><code>// 原点private Location location;// X轴上的单位向量private Vector originalVector;private float yaw = 0;private double radius = 1D;public RotatableCircle(Location location) {    this.location = location.clone();    originalVector = VectorUtils.getVector(location, location.clone().add(1, 0, 0));}@Overridepublic void run() {    // 我们假设是第一次yaw旋转, 那么是0, 所以我们先将originalVector旋转yaw个单位    Vector vectorYaw = VectorUtils.rotateVector(originalVector, yaw, 0);    // 之后我们将pitch进行 90 ~ -90 的一个循环用于将向量进行上下翻转    for (float pitch = 90; pitch &gt; -90; pitch--) {        Vector vector = VectorUtils.rotateVector(vectorYaw, 0, pitch);        // 这样得出来的vector只有一个半圆, 那么另外一个向量我们可以通过得到相反向量来制造出        Vector reverseVector = vector.clone().multiply(-1);        // 在正方向上绘制粒子        location.add(vector);        location.getWorld().spawnParticle(Particle.FLAME, location, 0);        location.subtract(vector);        // 在反方向上绘制粒子        location.add(reverseVector);        location.getWorld().spawnParticle(Particle.FLAME, location, 0);        location.subtract(reverseVector);    }    // 将yaw设定在0~360之间进行循环    if (yaw &gt;= 360) {        yaw = 0;    } else {        yaw++;    }}</code></pre><p>}</p><pre><code class="hljs plain">我们在代码中像下方一样调用</code></pre><p>RotatableCircle rotatableCircle = new RotatableCircle(location);<br>rotatableCircle.runTaskTimer(你插件的主类实例, 0L, 3L);</p><p>```<br><strong>最终的效果</strong><br><img src="https://upload-images.jianshu.io/upload_images/8109631-59e4a6143a87f196.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="最终效果"></p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
      <tag>数学</tag>
      
      <tag>MC特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的MC特效(二 | 向量基础)</title>
    <link href="/2018/12/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%BA%8C)/"/>
    <url>/2018/12/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h4><ul><li>导读</li><li>数学上的向量与BukkitAPI中的向量</li><li>利用向量进行画线操作</li><li>利用画线进行多边形的绘制</li><li>一个五角星</li></ul><hr><h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4><p>本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)<br>本教程使用的 Spigot1.10.2-R0.1-SNAPSHOT 核心<br>在阅读之前请确保你具有高中数学必修4和Java基础的知识<br>(没有我也会适当的解释的)</p><p>&lt;To初中生&gt;: 如果你是初中的话，别慌，你有趋向的概念就可以读懂本教程(应该吧…)<br>&lt;To高中生&gt;: 如果你还未学到关于上面的那本书，别慌学到了再来看也行233 (雾<br>&lt;To大学生&gt;: 没什么好说的…</p><hr><h4 id="1-数学上的向量与BukkitAPI中的向量"><a href="#1-数学上的向量与BukkitAPI中的向量" class="headerlink" title="1.数学上的向量与BukkitAPI中的向量"></a>1.数学上的向量与BukkitAPI中的向量</h4><p><strong>此处只讲平面向量</strong></p><p>在教程开始之前我们来谈一下数学上对向量的定义<br>*<em>定义:<br>*</em><br>向量由长度和方向组成，总是用来描述从一个点到另一个的移动。<br>和我们平常所说的数量不同的是，向量则是有了方向这一概念<br>那么我们利用图来理解一下向量</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-f9171d288c45fa74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图 1-1"></p><p>在 图 1-1 当中我们定义两个点一个是<strong>点A</strong>一个是<strong>点B</strong>，那么我们<strong>以A为起点，B为终点作一条有向线段</strong>，得到下图<br><img src="http://upload-images.jianshu.io/upload_images/8109631-b4f38fb09033b50d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图 1-2"></p><p>在 图1-2 当中我们作了一条<strong>有向线段</strong>，而这条有向线段我们称之为<strong>向量AB</strong>，那么这就是向量的一个基本定义</p><p><strong>向量的坐标表示: 假设A = (1, 3), B = (2, 4)，则向量AB = (2 - 1, 4 - 3)，即终点减起点<br>(在BukkitAPI中，向量以坐标来表示所以突出这一段)</strong></p><p>我们再来谈谈关于向量的一些相关概念<br><strong>向量的模:</strong> 若我们有一个向量AB，那么它的模可以使用 <strong>|AB|</strong> 来进行表示，表示的则是<strong>AB之间的距离，即向量AB的长度</strong><br><strong>单位向量:</strong> 我们把一个模等于1个单位长度的向量叫做单位向量<br><strong>相反向量:</strong> 与<strong>向量A</strong>长度相等，方向相反的向量，叫做向量<strong>A的相反向量</strong><br><strong>零向量:</strong> 我们把<strong>模长等于0</strong>的向量叫做零向量</p><hr><h4 id="向量的基本运算"><a href="#向量的基本运算" class="headerlink" title="向量的基本运算"></a>向量的基本运算</h4><p>向量是有加和乘的，那么我们根据以下的一些图来了解一下它们的基本运算，<br><img src="http://upload-images.jianshu.io/upload_images/8109631-aebba809ea979a09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"><br><strong>向量相加应满足平行四边形定则或三角形定则<br>若向量A = (1, 3), 向量B = (2, 4)，则向量A+向量B = (3, 7)</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-239da7f92cda0b66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p><strong>在上方我们给一个向量乘以-1，得到了反方向的向量，这个我们称之为相反向量<br>若向量A = (1, 3),向量A * 2 = (2, 4)<br>若向量A = (1, 3),向量A * -1 = (-1, -3)</strong></p><hr><h4 id="BukkitAPI上的向量-——-Vector"><a href="#BukkitAPI上的向量-——-Vector" class="headerlink" title="BukkitAPI上的向量 —— Vector"></a>BukkitAPI上的向量 —— Vector</h4><p>那么BukkitAPI上对向量的定义又是怎么样的呢？首先我们在 <strong>org.bukkit.util</strong> 包下找到一个叫<a href="https://docs.windit.net/Chinese_BukkitAPI/org/bukkit/util/Vector.html" target="_blank" rel="noopener">Vector</a>的类</p><p><strong>那么在BukkitAPI上，Vector类用于表示从一个Location到另一个Location的”趋势”。</strong></p><p>若我们想获取从LocationA到LocationB的向量，我们可以使用以下的代码，即<strong>终点减起点</strong></p><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 取第一个坐标到第二个坐标的向量</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> firstLocation  坐标1</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> secondLocation 坐标2</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@link</span> Vector&#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function">Vector <span class="hljs-title">getVector</span><span class="hljs-params">(Location firstLocation, Location secondLocation)</span> </span>&#123;    <span class="hljs-keyword">return</span> secondLocation.subtract(firstLocation).toVector();&#125;</code></pre><p><strong>请注意！这里的 secondLocation.subtract() 将会改变secondLocation的值</strong></p><h4 id="2-利用向量进行画线操作"><a href="#2-利用向量进行画线操作" class="headerlink" title="2.利用向量进行画线操作"></a>2.利用向量进行画线操作</h4><p>首先我们来看张图</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-fe75e046e164e74f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图 2-1"><br>图 2-1</p><p>在上方的图中，我们定义两个点，一个是A一个是B，那么对应到MC中它们就是两个Location，LocationA和LocationB，那么我们要怎么使用向量来给这两个点进行画线的操作呢？</p><p>思路：</p><ul><li>首先我们要获取一下这两个点的一个向量，我们称之为向量AB</li><li>之后我们把向量AB转为单位向量，方向不变</li><li>在Vector类里有个叫multiply的函数，这个函数是对Vector进行乘的操作</li><li>若向量AB乘以2，那么它的长度就会乘以了2，之后我们再使用locationA的add函数进行增加Vector，这样我们就可以获得在AB上期中的一个点了，然后我们进行遍历的操作以此类推…（看不懂的话喝杯茶…）</li></ul><p>我们把上方的思路转为几何来理解一下<br><img src="http://upload-images.jianshu.io/upload_images/8109631-66c189ab14d15704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"><br>有了上面的思路，我们就可以打代码了</p><p>首先我们要获取它们向量，这里我调用了<strong>location的clone函数</strong>，因此不会改变locB的值</p><pre><code class="hljs Vector">之后我们先获取一下该向量的长度，等下要用&#96;&#96;&#96;double vectorLength &#x3D; vectorAB.length();</code></pre><p>然后我们再把该向量转为单位向量</p><pre><code class="hljs vectorAB.normalize();```">然后我们就需要利用for循环**来计算出一个每一个需要multiply的值**</code></pre><p>for (double i = 0; i &lt; vectorLength; i += 0.1) {<br>     // 这里如果我们直接进行multiply的话则会修改vectorAB的值，所以我们先clone再multiply<br>     Vector vector = vectorAB.clone().multiply(i);<br>}</p><pre><code class="hljs markdown"><span class="hljs-strong">**i的类型:**</span><span class="hljs-bullet">- </span>首先我们来解释为什么这里的i的类型为double<span class="hljs-bullet">- </span>因为在坐标运算中，精确度是比较高的，当两个点相近时可能他们的值还没有到1，可能只有0.8左右的长度，所以我们使用double来修饰<span class="hljs-strong">**结束值:**</span> 之后我们来谈谈这里为什么要循环到向量的模长的时候就结束，在上面的思路我们只举了当i == 2时的一个情况，而我们想获得这两个点之间的点，所以我们要填入向量的模长<span class="hljs-strong">**步长:**</span> 这里我们依然修改了循环的步长，那么它的作用是什么？其实就是在设定每一个add出来后的点的<span class="hljs-strong">**间距**</span> （这里我不懂怎么解释，直接画了个图给你们，按照图来理解会很好哦~）![<span class="hljs-string">image</span>](<span class="hljs-link">http://upload-images.jianshu.io/upload_images/8109631-03035b9b0cddc4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)那么我就会得到每一次从点A往点B进行逐步偏移的一个效果，然后我们每次给locA，进行add的操作就可以得到当前循环应该得到的Location</code></pre><p>locA.add(vector);<br>locA.getWorld().playEffect(locA, Effect.HAPPY_VILLAGER, 1); // 这里是播放粒子的代码…<br>locA.subtract(vector);</p><pre><code class="hljs asciidoc">*<span class="hljs-strong">*完整代码:*</span><span class="hljs-strong">*</span></code></pre><p>public static void buildLine(Location locA, Location locB) {<br>    Vector vectorAB = locB.clone().subtract(locA).toVector();<br>    double vectorLength = vectorAB.length();<br>    vectorAB.normalize();<br>    for (double i = 0; i &lt; vectorLength; i += 0.1) {<br>        Vector vector = vectorAB.clone().multiply(i);<br>        locA.add(vector);<br>        locA.getWorld().playEffect(locA, Effect.HAPPY_VILLAGER, 1);<br>        locA.subtract(vector);<br>    }<br>}</p><pre><code class="hljs markdown">游戏内的效果:![<span class="hljs-string">image</span>](<span class="hljs-link">http://upload-images.jianshu.io/upload_images/8109631-c32ef6631b2344a8.gif?imageMogr2/auto-orient/strip</span>)<span class="hljs-quote">&gt; **注: 以下的内容则是对于画线的一些实践，跟上方的理论知识有部分的联系，所以可看可不看，不属于应掌握内容**</span><span class="hljs-section">#### 3.利用画线进行多边形的绘制</span>在第一章的时候，我们利用三角函数画出了一个圆，如果我们向画的是一个多边形该怎么做呢？这里顺便讲个小故事，在很久以前有个人叫<span class="hljs-strong">**阿基米德**</span>，他使用了一种叫做<span class="hljs-strong">**割圆法**</span>的方式计算出了圆周率，那么这个<span class="hljs-strong">**割圆法的步骤**</span>可以[<span class="hljs-string">看这个视频</span>](<span class="hljs-link">https://www.bilibili.com/video/av25406675</span>)来了解一下那么我们提到这个割圆法有什么用呢，首先这个割圆法利用的是<span class="hljs-strong">**内接六边形**</span>，再使用<span class="hljs-strong">**勾股定理**</span>求出来的，之后再<span class="hljs-strong">**内接八边形，十六边形**</span>一直下去...那么我们多边形始终都离不开一个圆，当然了是内接的多边形，而且还是<span class="hljs-strong">**规则的多边形**</span>，那么如果我们要画一个五边形或者三角形该怎么画呢？首先既然是多边形，就会有点，我们找到点之后就成功了一半，我们来看一张图![<span class="hljs-string">图 3-1</span>](<span class="hljs-link">http://upload-images.jianshu.io/upload_images/8109631-7ec23efd4f399402.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)在上图中我们找到了五个点，这五个点，每两两之间的夹角都为72°，这72°是怎么来的呢？我们利用<span class="hljs-strong">**360° / 5就可以得到72°，那么从360°/5得到的是一个单位圆中平均分成五块，且每块跟X轴正半轴的夹角都为72的倍数**</span>，那么这五个点就是这么找出来的我们把它放入代码中看看要怎么操作我们依然使用玩家的location作为原点O，之后我们实例化一个List用于保存这五个点</code></pre><p>Location playerLocation = player.getLocation();<br>List<Location> locations = Lists.newArrayList();</p><pre><code class="hljs angelscript">因为我们只是需要<span class="hljs-number">72</span>的倍数的角度，所以我们把步长修改为 i += <span class="hljs-number">72</span> (等价于 i = i + <span class="hljs-number">72</span>)</code></pre><p>for (int i = 0; i &lt; 360; i += 72) {<br>    // 转弧度制<br>    double radians = Math.toRadians(i);<br>    locations.add(playerLocation.clone().add(3 *<br>    Math.cos(radians), 0D, 3 * Math.sin(radians)));<br>}</p><pre><code class="hljs markdown">为了以便于观看我将每次cos和sin计算的值都乘以3来扩大点到原点的距离之后我们的locations里就存放有那5个点了如果我们现在对这五个点播放粒子的话你可以看到以下这样的图![<span class="hljs-string">image</span>](<span class="hljs-link">http://upload-images.jianshu.io/upload_images/8109631-e8916358317f7123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)那么我们剩下的就是每个点依次顺序进行画线操作，然后你就可以看到以下的效果了![<span class="hljs-string">image</span>](<span class="hljs-link">http://upload-images.jianshu.io/upload_images/8109631-c9268d1984e316c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)<span class="hljs-section">#### 4.一个五角星</span>其实也没什么好说的...看代码吧...</code></pre><p>Location playerLocation = player.getLocation();<br>List<Location> locations = Lists.newArrayList();<br>for (int i = 0; i &lt; 360; i += 72) {<br>    // 转弧度制<br>    double radians = Math.toRadians(i);<br>    locations.add(playerLocation.clone().add(3 * Math.cos(radians), 0D, 3 * Math.sin(radians)));<br>}</p><p>buildLine(locations.get(0), locations.get(2));<br>buildLine(locations.get(0), locations.get(3));<br>buildLine(locations.get(1), locations.get(3));<br>buildLine(locations.get(1), locations.get(4));<br>buildLine(locations.get(2), locations.get(4));</p><p>```<br><strong>备注: 这里的buildLine是上方我所发出来的一个方法哦</strong></p><p>上方的locations的画线操作我们可以利用图来理解一下就可以</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-6bebbbb151b102c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p>为了方便解释我给每个点都起了名字括号内的是它在locations中的下标</p><p>如果我们要画一个五角星，可以这么画<br>连接AC, AD，即0 -&gt; 2，0 -&gt; 3<br>连接BD, BE，即1 -&gt; 3，1 -&gt; 4<br>连接CE，即 2 -&gt; 4<br>然后你就可以看到这样的五角星了<br><img src="http://upload-images.jianshu.io/upload_images/8109631-eccd92b040cd93db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
      <tag>数学</tag>
      
      <tag>MC特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的MC特效(一 | 在X, Z轴上的画圆操作)</title>
    <link href="/2018/05/20/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%B8%80)/"/>
    <url>/2018/05/20/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h3><ul><li>导读</li><li>数学与Minecraft的融合</li><li>利用数学在Minecraft中画一个圆</li><li>利用数学在Minecraft中画一个球</li></ul><hr><h5 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h5><p>本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)<br>本教程使用的 Spigot1.10.2-R0.1-SNAPSHOT 核心<br>在阅读之前请确保你具有高中数学必修4和Java基础的知识<br>(没有我也会适当的解释的)</p><p>&lt;初中生&gt;: 如果你是初中的话，别慌，你有函数的概念就可以读懂本教程(应该吧…)<br>&lt;高中生&gt;: 如果你还未学到关于上面的两本书，别慌学到了再来看也行233 (雾</p><hr><h5 id="数学与Minecraft的融合"><a href="#数学与Minecraft的融合" class="headerlink" title="数学与Minecraft的融合"></a>数学与Minecraft的融合</h5><p>首先我们都知道Minecraft是一个3D游戏，所以它就有了XYZ这三个轴，那么我们可以看如下的一张图来了解一下</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-2d19dbfb979d9c1c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p><strong>本教程暂不涉及关于Y轴的相关内容，所以我们可以先从平面直角坐标系来分析</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://upload-images.jianshu.io/upload_images/8109631-bdac487be24902d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></h2><h5 id="利用数学在Minecraft中画一个圆"><a href="#利用数学在Minecraft中画一个圆" class="headerlink" title="利用数学在Minecraft中画一个圆"></a>利用数学在Minecraft中画一个圆</h5><p><strong>以下内容需要sin函数与cos函数的相关知识！</strong><br>首先呢我们先来看一张图（自己用word画的2333）<br><img src="http://upload-images.jianshu.io/upload_images/8109631-0332f34619e797e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p><strong>分析:</strong><br>     首先这个坐标系有一个<strong>单位圆</strong>(半径为1的圆)，然后我们看到<strong>角α为30°</strong>，之后<strong>点P的横坐标为 √3/2 纵坐标为 1/2</strong></p><p>然后我们再看下图</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-17c456f2fb78ae8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p>那么我们是否可以这么认为，点P的横坐标其实是 cos(30°) 而纵坐标就是 sin(30°)呢？</p><blockquote><p>补充: 如果你已经有了参数方程的概念那么，这里你可以忽略了 —— 2019/1/12</p></blockquote><blockquote><p>PI 代表圆周率π, 之后π = 180° (别问我为什么，课堂上自己学去233)*</p></blockquote><p><strong>P(cos(30°), sin(30°))， 弧度制: P(cos(PI/6), sin(PI/6))</strong></p><p>那么P的横坐标和纵坐标都是可以利用函数 cos和sin 求出，那么我们为什么不可以<strong>遍历一下把360°全部都给算出</strong>呢？所以我看写出下方的代码这样我们就可以把一周角里所有的角度都给遍历了一便，并且我们都算出了<strong>每个角度所对应的cos值和sin值</strong>吧，然后我们需要把他们作用到Minecraft当中</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 我们把玩家脚下的location作为是原点O </span>Location location = player.get<span class="hljs-constructor">Location()</span>; for (<span class="hljs-built_in">int</span> degree = <span class="hljs-number">0</span>; degree &lt; <span class="hljs-number">360</span>; degree++) &#123;    double radians = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Radians(<span class="hljs-params">degree</span>)</span>;    double x = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>cos(radians);    double y = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sin(radians);&#125;</code></pre><p>那么在上图的for循环语句块中我们有两个变量 x y，也就是 <strong>P(x, y)</strong> 吧，之后我们回头看一下for循环语句块外的那个<strong>变量location</strong>，那个我们可以理解成是在上图中的<strong>原点O</strong>，那么我们做个假设，我们需要把点P转换成MC中的Location要怎么做？，其实很简单</p><pre><code class="hljs dockerfile">location.<span class="hljs-keyword">add</span><span class="bash">(x, 0, y);</span></code></pre><p>我们把location的X轴假想为0, Z轴假想为0（这里的X轴和Z轴指的是Minecraft中的那两个轴）即<strong>图中原点O为(0, 0)</strong>，那么<strong>在Minecraft中不可能任何时候原点的X Z轴都是0</strong>，所以我们需要做相加的操作</p><p>（上面可能会听得一头雾水，简单来说当<strong>原点O不为(0, 0)时</strong>，假设为(2, 2)，那么我们要做的是给<strong>玩家的周围建立圆</strong>吧，那么这时候点P的坐标应该为 <strong>P(2 + x, 2 + y)）</strong></p><blockquote><p>要是还听不懂的话那就去喝杯茶，洗个澡吧2333</p></blockquote><p>那么我们可以做以下的操作了</p><pre><code class="hljs glsl"><span class="hljs-keyword">location</span>.add(x, <span class="hljs-number">0</span>D, y);<span class="hljs-comment">// 播放粒子</span><span class="hljs-keyword">location</span>.getWorld.playEffect(<span class="hljs-keyword">location</span>, Effect.HAPPY_VILLAGER, <span class="hljs-number">1</span>);<span class="hljs-comment">// 为什么要减？因为我们要确保原点是不变的状态才可以哦~</span><span class="hljs-keyword">location</span>.subtract(x, <span class="hljs-number">0</span>D, y);</code></pre><p>游戏内效果<br><img src="http://upload-images.jianshu.io/upload_images/8109631-512ddf977900c346.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="游戏内的效果"></p><p>完整代码</p><pre><code class="hljs glsl"><span class="hljs-comment">// 我们把玩家脚下的location作为是原点O</span>Location <span class="hljs-keyword">location</span> = player.getLocation();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> degree = <span class="hljs-number">0</span>; degree &lt; <span class="hljs-number">360</span>; degree++) &#123;    <span class="hljs-type">double</span> <span class="hljs-built_in">radians</span> = Math.toRadians(degree);    <span class="hljs-type">double</span> x = Math.<span class="hljs-built_in">cos</span>(<span class="hljs-built_in">radians</span>);    <span class="hljs-type">double</span> y = Math.<span class="hljs-built_in">sin</span>(<span class="hljs-built_in">radians</span>);    <span class="hljs-keyword">location</span>.add(x, <span class="hljs-number">0</span>, y);    <span class="hljs-keyword">location</span>.getWorld().playEffect(<span class="hljs-keyword">location</span>, Effect.HAPPY_VILLAGER, <span class="hljs-number">1</span>);    <span class="hljs-keyword">location</span>.subtract(x, <span class="hljs-number">0</span>, y);&#125;</code></pre><h5 id="利用数学在Minecraft中画一个球"><a href="#利用数学在Minecraft中画一个球" class="headerlink" title="利用数学在Minecraft中画一个球"></a>利用数学在Minecraft中画一个球</h5><p>首先我们来观察一下sin的<strong>函数图像</strong>，具体如下</p><p><img src="https://upload-images.jianshu.io/upload_images/8109631-c004142745f40231.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图 2-1"></p><p>从上图可以看出 sin函数 始终在 1~-1 之间徘徊，所以我们认为它是有<strong>周期性</strong>的，那么这跟球的生成有什么联系呢？我们看下图</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-0a5961213221bee9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图 2-2"></p><p>首先这是一个球对吧，然后呢我在球上画了几个<strong>横截面(</strong>才不是什么旋风<strong>)</strong>出来，那么通过上图我们是不是可以得出一个结论，一个球体其实是由<strong>无数个圆</strong>构成的？只是<strong>它们的半径不同</strong>对吧。那这跟sin函数有啥联系呢？</p><p>首先我们回到sin的函数图像，我们看<strong>当x在0~π之间时</strong>连起来的y轴是不是像一个半圆啊？而且它们的<strong>半径(这里的半径可以理解为sin函数中的y轴)</strong>也是不同的，那么我们是不是可以这么认为，我们只需要 <strong>0 ~ **</strong>π** 之间的x值，然后代入函数当中就可以求出对应的y轴的值了？</p><p>那么 <strong>0 ~ π</strong> 是什么值呢？其实在上面的圆中我就讲过 <strong>π=180°，</strong>所以我们求得其实就是 <strong>sin(0 ~ 180°)。</strong></p><p>那么有了上面的思路我们可以<strong>求出每个圆的半径</strong>对吧，那么我们写出下面的代码</p><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> (double i = 0; i &lt; 180; i++) &#123;    double radians = Math.toRadians(i);         double<span class="hljs-built_in"> radius </span>= Math.sin(radians);&#125;</code></pre><p>在上方的代码当中我们求出了一个球中每个圆的半径, 但是我们还需要考虑一件事，我们是不是要规定一下每个圆之间的距离啊？</p><p>那么我们引入<strong>cos</strong>的函数图像<br><img src="https://upload-images.jianshu.io/upload_images/8109631-1c1ac82cccdbfd35.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图 2-3"></p><p>从上图可以看出 f(x) = cos(x),<br>当<strong>x=0</strong>时, f(x)则为1.<br>当<strong>x=π</strong>时，f(x)则为-1.</p><p>那么我跟sin的函数图像联系一下, 在上面的代码中我们发现，radius的值是从小到大再到小，那么我们想一下，如果半径是小的那么那个圆是也是小的，而我们要画的圆是<strong>从上往下</strong>画的（观察图 2-2）对吧，所以我们是不是要给那个<strong>最小的圆的y轴是最高的</strong>？（没看懂？喝杯茶吧）而<strong>cos函数</strong>就可以帮我们达到这一点，所以我们写出以下的代码</p><pre><code class="hljs double">那么这样我们就可以获得**当前for循环时**那个圆的高度了。在上面的结构中我们得到了当前圆的**半径和高度**，那么我们要怎么通过这两个东西画出来呢？我们在第三章画圆时曾经做过这么一个操作</code></pre><p>for (int degree = 0; degree &lt; 360; degree++) {<br>    double radians = Math.toRadians(degree);<br>    double x = Math.cos(radians);<br>    double y = Math.sin(radians);<br>}</p><pre><code class="hljs asciidoc">上方的代码中我们只能制造出一个*<span class="hljs-strong">*半径为1*</span><span class="hljs-strong">*的圆，那么我们想扩大它的半径需要怎么做？</span><span class="hljs-strong"></span><span class="hljs-strong">我们这里又引入一个函数*</span><span class="hljs-strong">*y=Asin(ωx + φ)*</span>* <span class="hljs-strong">*(这里的sin也可以为cos)*</span>，其实这个函数跟sin函数差不多只不过多了几个变量，那么这里我们只需要考虑A的值，为什么呢？我们来看一下这个函数在数学上的定义：<span class="hljs-bullet">*   </span><span class="hljs-strong">*φ（初相位）：决定波形与X轴位置关系或横向移动距离（左加右减）*</span><span class="hljs-bullet">*   </span><span class="hljs-strong">*ω：决定周期（最小正周期T=2π/|ω|）*</span><span class="hljs-bullet">*   </span>*<span class="hljs-strong">*A：决定峰值（即纵向拉伸压缩的倍数）*</span><span class="hljs-strong">*</span><span class="hljs-strong"></span><span class="hljs-strong">*</span><span class="hljs-strong">*由于这里我们只考虑A所以我们可以把上方的函数简写为 y = Asin(x)，假设我们的A为2，那就是sin(x) *</span> 2了，那么反应在函数图像上是这样的*<span class="hljs-strong">*</span><span class="hljs-strong"></span><span class="hljs-strong">*</span><span class="hljs-strong">*![image](http://upload-images.jianshu.io/upload_images/8109631-d8fa9a9d746e0d0c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)*</span>* 那么有了上面的概念*<span class="hljs-strong">*我们不妨使用 Math.cos(x) *</span> 半径 来扩大本次循环时所对应的半径*<span class="hljs-strong">*，所以我们写出以下的代码</span></code></pre><p>for (double j = 0; j &lt; 360; j ++) {<br>    // 依然需要做角度转弧度的操作<br>    double radiansCircle = Math.<em>toRadians</em>(j);<br>    double x = Math.<em>cos</em>(radiansCircle) * radius;<br>    double z = Math.<em>sin</em>(radiansCircle) * radius;<br>}</p><pre><code class="hljs makefile">那么这样就可以控制好本次循环我们需要这个圆多少半径了，那么我们写好之后就可以放在Minecraft中看看效果<span class="hljs-section">完整代码:</span></code></pre><p>for (double i = 0; i &lt; 180; i++) {<br>    // 依然要做角度与弧度的转换<br>    double radians = Math.toRadians(i);<br>    // 计算出来的半径<br>    double radius = Math.sin(radians);<br>    double y = Math.cos(radians);<br>    for (double j = 0; j &lt; 360; j++) {<br>        // 依然需要做角度转弧度的操作<br>        double radiansCircle = Math.toRadians(j);<br>        double x = Math.cos(radiansCircle) * radius;<br>        double z = Math.sin(radiansCircle) * radius;<br>        location.add(x, y, z);<br>        location.getWorld().playEffect(location, Effect.HAPPY_VILLAGER, 1);<br>        location.subtract(x, y, z);<br>    }<br>}</p><pre><code class="hljs markdown">游戏内的效果![<span class="hljs-string">效果</span>](<span class="hljs-link">http://upload-images.jianshu.io/upload_images/8109631-78b42b28cadfa8ba.gif?imageMogr2/auto-orient/strip</span>)然后你就会发现你的游戏卡得一匹2333，因为我们是在360°全方位的进行渲染粒子的操作2333，但实际业务中我们可能并不需要做这种需求，那么我们就需要做一个关于跳跃的操作呗，我们看下面的代码</code></pre><p>for (double i = 0; i &lt; 180; i += 180 / 6) {<br>    // 依然要做角度与弧度的转换<br>    double radians = Math.toRadians(i);<br>    // 计算出来的半径<br>    double radius = Math.sin(radians);<br>    double y = Math.cos(radians);<br>    for (double j = 0; j &lt; 360; j += 180 / 6) {<br>        // 依然需要做角度转弧度的操作<br>        double radiansCircle = Math.toRadians(j);<br>        double x = Math.cos(radiansCircle) * radius;<br>        double z = Math.sin(radiansCircle) * radius;<br>        location.add(x, y, z);<br>        location.getWorld().playEffect(location, Effect.HAPPY_VILLAGER, 1);<br>        location.subtract(x, y, z);<br>    }<br>}</p><p>```<br>跟上面的代码不同的是我在遍历的时候修改了<strong>步长(step)</strong>，那这一个有什么讲究呢？我们在每一次循环给 i 和 j就加的是<strong>30</strong>了对吧，而不是自加1，</p><p>那么我们看<strong>第一层循环</strong>，这一层循环控制的步长其实是我们其实需要多少圈，为什么呢？我们看下面的图来理解一下</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-c5aa3f61a470cab2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p>这里我为了方便读者理解我把图 2-1 旋转了一下，上图我们假想黑点是玩家的location，那么那几个红点就是我们把<strong>步长</strong>修改后所得到的产物</p><p>那么第二层循环我修改的步长又是什么意思呢？我们也拿张图来理解一下<img src="http://upload-images.jianshu.io/upload_images/8109631-0163144e4c0e42f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p>上图中每个角的度数都是30°，那么我修改了步长之后是不是我只会在这几个黑点上面做playEffect()的操作了？（看不懂的话喝口水再来看233）</p><p>修改了步长后游戏内的效果:<br><img src="http://upload-images.jianshu.io/upload_images/8109631-46416920308dc784.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="image"></p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>内容依然是挺少的。。希望能教给读者一些东西吧233 </p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
      <tag>数学</tag>
      
      <tag>MC特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
