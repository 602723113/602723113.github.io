<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LaTeX与Markdown</title>
    <link href="/2020/04/02/Latex%E4%B8%8EMarkdown/"/>
    <url>/2020/04/02/Latex%E4%B8%8EMarkdown/</url>
    
    <content type="html"><![CDATA[<p>$$LaTeX$$<br>总所周知, LaTeX是一个优秀的基于TeX的文档排版系统。<br>在Markdown中插入数学公式的语法是 <code>$数学公式$</code> 和 <code>$$数学公式$$</code>。</p><hr><h1 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h1><p>行内公式是可以让公式在文中与文字或其他东西混编，<strong>不独占一行</strong>.在数学模式下, 符号会使用单独的字体<br>字母通常是<em>倾斜</em>的意大利体, 数字和符号则是直立体. 而且,数学符号之间的距离也与一般的水平模式不同:</p><table><thead><tr><th>实例</th><th>显示</th></tr></thead><tbody><tr><td><code>$2x+3y=34$</code></td><td>$2x+3y=34$</td></tr><tr><td>2x+3y=34</td><td>2x+3y=34</td></tr></tbody></table><hr><h1 id="独立公式"><a href="#独立公式" class="headerlink" title="独立公式"></a>独立公式</h1><p>独立公式顾名思义，就是单独的占一行<br>比如 <code>$$E = mc^2$$</code> 其可以展示为<br>$$E = mc^2$$</p><p>它单独占用了一行, 而不是在 <strong>单行</strong> 内显示</p><hr><h1 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h1><p>在独立公式中使用\\来换行<br>示例: </p><pre><code>$$2x+3y=34\\x+4y=25$$</code></pre><p>显示:<br>$$<br>2x+3y=34\\<br>x+4y=25<br>$$</p><blockquote><p><strong>如果你的解析器会自动转义, 那么请写四个 <code>\\\\</code></strong></p></blockquote><hr><h1 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h1><table><thead><tr><th>符号</th><th>实例</th><th>显示</th></tr></thead><tbody><tr><td>上下标</td><td><code>S=a_{1}^2+a_{2}^2+a_{3}^2$</code></td><td>$S=a_{1}^2+a_{2}^2+a_{3}^2$</td></tr><tr><td>括号</td><td><code>$f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace$</code></td><td>$f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace$</td></tr><tr><td>分数</td><td><code>$\frac{1}{3} 与 \cfrac{1}{3}$</code></td><td>$\frac{1}{3} 与 \cfrac{1}{3}$</td></tr><tr><td>开方</td><td><code>$\sqrt[3]{X}$ 和 $\sqrt{5 - x}$</code></td><td>$\sqrt[3]{X}$ 和 $\sqrt{5 - x}$</td></tr></tbody></table><hr><h1 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h1><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th>符号</th><th>显示</th></tr></thead><tbody><tr><td><code>\pm</code></td><td>$\pm$</td></tr><tr><td><code>\times</code></td><td>$\times$</td></tr><tr><td><code>\div</code></td><td>$\div$</td></tr><tr><td><code>\mid</code></td><td>$\mid$</td></tr><tr><td><code>\nmid</code></td><td>$\nmid$</td></tr><tr><td><code>\cdot</code></td><td>$\cdot$</td></tr><tr><td><code>\circ</code></td><td>$\circ$</td></tr><tr><td><code>\ast</code></td><td>$\ast$</td></tr><tr><td><code>\bigodot</code></td><td>$\bigodot$</td></tr><tr><td><code>\bigotimes</code></td><td>$\bigotimes$</td></tr><tr><td><code>\bigoplus</code></td><td>$\bigoplus$</td></tr><tr><td><code>\leq</code></td><td>$\leq$</td></tr><tr><td><code>\geq</code></td><td>$\geq$</td></tr><tr><td><code>\neq</code></td><td>$\neq$</td></tr><tr><td><code>\approx</code></td><td>$\approx$</td></tr><tr><td><code>\equiv</code></td><td>$\equiv$</td></tr><tr><td><code>\sum</code></td><td>$\sum$</td></tr><tr><td><code>\prod</code></td><td>$\prod$</td></tr></tbody></table><hr><h2 id="对数运算符"><a href="#对数运算符" class="headerlink" title="对数运算符"></a>对数运算符</h2><table><thead><tr><th>符号</th><th>显示</th></tr></thead><tbody><tr><td><code>\log</code></td><td>$\log$</td></tr><tr><td><code>\lg</code></td><td>$\lg$</td></tr><tr><td><code>\ln</code></td><td>$\ln$</td></tr></tbody></table><hr><h2 id="三角运算符"><a href="#三角运算符" class="headerlink" title="三角运算符"></a>三角运算符</h2><table><thead><tr><th>符号</th><th>显示</th></tr></thead><tbody><tr><td><code>\bot</code></td><td>$\bot$</td></tr><tr><td><code>\angle</code></td><td>$\angle$</td></tr><tr><td><code>\sin</code></td><td>$\sin$</td></tr><tr><td><code>\cos</code></td><td>$\cos$</td></tr><tr><td><code>\tan</code></td><td>$\tan$</td></tr><tr><td><code>\cot</code></td><td>$\cot$</td></tr><tr><td><code>\sec</code></td><td>$\sec$</td></tr><tr><td><code>\csc</code></td><td>$\csc$</td></tr></tbody></table><hr><h2 id="微积分运算符"><a href="#微积分运算符" class="headerlink" title="微积分运算符"></a>微积分运算符</h2><table><thead><tr><th>符号</th><th>显示</th></tr></thead><tbody><tr><td><code>\prime</code></td><td>$\prime$</td></tr><tr><td><code>\int</code></td><td>$\int$</td></tr><tr><td><code>\iint</code></td><td>$\iint$</td></tr><tr><td><code>\iiint</code></td><td>$\iiint$</td></tr><tr><td><code>\oint</code></td><td>$\oint$</td></tr><tr><td><code>\lim</code></td><td>$\lim$</td></tr><tr><td><code>\infty</code></td><td>$\infty$</td></tr><tr><td><code>\nabls</code></td><td>$∇$</td></tr><tr><td><code>\mathrm{d}</code></td><td>$\mathrm{d}$</td></tr></tbody></table><hr><h2 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h2><table><thead><tr><th>符号</th><th>显示</th></tr></thead><tbody><tr><td><code>\emptyset</code></td><td>$\emptyset$</td></tr><tr><td><code>\in</code></td><td>$\in$</td></tr><tr><td><code>\notin</code></td><td>$\notin$</td></tr><tr><td><code>\subset</code></td><td>$\subset$</td></tr><tr><td><code>\subseteq</code></td><td>$\subseteq$</td></tr><tr><td><code>\supseteq</code></td><td>$\supseteq$</td></tr><tr><td><code>\bigcap</code></td><td>$\bigcap$</td></tr><tr><td><code>\bigcup</code></td><td>$\bigcup$</td></tr><tr><td><code>\bigvee</code></td><td>$\bigvee$</td></tr><tr><td><code>\bigwedge</code></td><td>$\bigwedge$</td></tr><tr><td><code>\biguplus</code></td><td>$\biguplus$</td></tr><tr><td><code>\bigsqcup</code></td><td>$\bigsqcup$</td></tr></tbody></table><hr><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table><thead><tr><th>代码</th><th>大写</th><th>代码</th><th>小写</th></tr></thead><tbody><tr><td><code>A</code></td><td>$A$</td><td><code>\alpha</code></td><td>$\alpha$</td></tr><tr><td><code>B</code></td><td>$B$</td><td><code>\beta</code></td><td>$\beta$</td></tr><tr><td><code>\Gamma</code></td><td>$\Gamma$</td><td><code>\gamma</code></td><td>$\gamma$</td></tr><tr><td><code>\Delta</code></td><td>$\Delta$</td><td><code>\delta</code></td><td>$\delta$</td></tr><tr><td><code>E</code></td><td>$E$</td><td><code>\epsilon</code></td><td>$\epsilon$</td></tr><tr><td><code>Z</code></td><td>$Z$</td><td><code>\zeta</code></td><td>$\zeta$</td></tr><tr><td><code>H</code></td><td>$H$</td><td><code>\eta</code></td><td>$\eta$</td></tr><tr><td><code>\Theta</code></td><td>$\Theta$</td><td><code>\theta</code></td><td>$\theta$</td></tr><tr><td><code>I</code></td><td>$I$</td><td><code>\iota</code></td><td>$\iota$</td></tr><tr><td><code>K</code></td><td>$K$</td><td><code>\kappa</code></td><td>$\kappa$</td></tr><tr><td><code>Lambda</code></td><td>$Lambda$</td><td><code>\lambda</code></td><td>$\lambda$</td></tr><tr><td><code>M</code></td><td>$M$</td><td><code>\mu</code></td><td>$\mu$</td></tr><tr><td><code>N</code></td><td>$N$</td><td><code>\nu</code></td><td>$\nu$</td></tr><tr><td><code>Xi</code></td><td>$Xi$</td><td><code>\xi</code></td><td>$\xi$</td></tr><tr><td><code>O</code></td><td>$O$</td><td><code>\omicron</code></td><td>$\omicron$</td></tr><tr><td><code>\Pi</code></td><td>$\Pi$</td><td><code>\pi</code></td><td>$\pi$</td></tr><tr><td><code>P</code></td><td>$P$</td><td><code>\rho</code></td><td>$\rho$</td></tr><tr><td><code>\Sigma</code></td><td>$\Sigma$</td><td><code>\sigma</code></td><td>$\sigma$</td></tr><tr><td><code>T</code></td><td>$T$</td><td><code>\tau</code></td><td>$\tau$</td></tr><tr><td><code>\Upsilon</code></td><td>$\Upsilon$</td><td><code>\upsilon</code></td><td>$\upsilon$</td></tr><tr><td><code>\Phi</code></td><td>$\Phi$</td><td><code>\phi</code></td><td>$\phi$</td></tr><tr><td><code>X</code></td><td>$X$</td><td><code>\chi</code></td><td>$\chi$</td></tr><tr><td><code>\Psi</code></td><td>$\Psi$</td><td><code>\psi</code></td><td>$\psi$</td></tr><tr><td><code>\Omega</code></td><td>$\Omega$</td><td><code>\omega</code></td><td>$\omega$</td></tr></tbody></table><hr><h2 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h2><table><thead><tr><th>符号</th><th>显示</th></tr></thead><tbody><tr><td><code>(</code></td><td>$($</td></tr><tr><td><code>)</code></td><td>$($</td></tr><tr><td><code>[ 或 \lbrack</code></td><td>$\lbrack$</td></tr><tr><td><code>] 或 \rbrack</code></td><td>$\rbrack$</td></tr><tr><td><code>\{ 或\lbrace</code></td><td>$($</td></tr><tr><td><code>\} 或\rbrace</code></td><td>$($</td></tr><tr><td><code>\langle</code></td><td>$\langle$</td></tr><tr><td><code>\rangle</code></td><td>$\rangle$</td></tr><tr><td><code>\lfloor</code></td><td>$\lfloor$</td></tr><tr><td><code>\rfloor</code></td><td>$\rfloor$</td></tr><tr><td><code>/</code></td><td>$/$</td></tr><tr><td><code>\backslash</code></td><td>$\backslash$</td></tr><tr><td><code>\uparrow</code></td><td>$\uparrow$</td></tr><tr><td><code>\Uparrow</code></td><td>$\Uparrow$</td></tr><tr><td><code>\downarrow</code></td><td>$\downarrow$</td></tr><tr><td><code>\Downarrow</code></td><td>$\Downarrow$</td></tr><tr><td><code>\updownarrow</code></td><td>$\updownarrow$</td></tr><tr><td><code>\Updownarrow</code></td><td>$\Updownarrow$</td></tr><tr><td><code>\leftarrow</code></td><td>$\leftarrow$</td></tr><tr><td><code>\Leftarrow</code></td><td>$\Leftarrow$</td></tr><tr><td><code>\rightarrow</code></td><td>$\rightarrow$</td></tr><tr><td><code>\Rightarrow</code></td><td>$\Rightarrow$</td></tr><tr><td><code>\vert</code></td><td>$\vert$</td></tr><tr><td><code>\Vert</code></td><td>$\Vert$</td></tr><tr><td><code>\lceil</code></td><td>$\lceil$</td></tr><tr><td><code>\rceil</code></td><td>$\rceil$</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>其他教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可能是最简单Scoreboard教程</title>
    <link href="/2020/03/29/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E7%AE%80%E5%8D%95Scoreboard%E6%95%99%E7%A8%8B/"/>
    <url>/2020/03/29/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E7%AE%80%E5%8D%95Scoreboard%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h2><ul><li>导读</li><li>Scoreboard的基本概念</li><li>使用Scoreboard进行展示数据给玩家</li><li>制作无闪计分板</li><li>如何使用Minecraft自带的Team</li></ul><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><del>好久没有更新教程了，woc昨天就发过教程（锡兰梗</del></p><p>本教程使用的 PaperSpigot1.15.2-R0.1-SNAPSHOT 核心<br>在阅读之前请确保你具有Java基础的知识<strong>(别问，问就挨打)</strong></p><p>To 读者: 本教程适合所有年龄向的人，因为我们是面向剪切板编程</p><h2 id="Scoreboard的基本概念"><a href="#Scoreboard的基本概念" class="headerlink" title="Scoreboard的基本概念"></a>Scoreboard的基本概念</h2><p>在教程开始前我们来了解一下Scoreboard  </p><ul><li><strong>记分板</strong>（Scoreboard）系统是一套通过命令操纵的复杂游戏机制。主要为地图作者与服务器运营者准备，记分板可用多种形式追踪、设置并列出玩家及实体的分数。</li><li><strong>记分项</strong>（Objective）由<strong>名称</strong>（name）、<strong>显示名称</strong>（display name）、<strong>准则</strong>（criteria）以及每位玩家（及实体UUID）所对应的整数数据组成。分数的范围为<strong>-2,147,483,648</strong>至<strong>2,147,483,647</strong>没有小数。</li><li><a href="https://minecraft-zh.gamepedia.com/%E8%AE%B0%E5%88%86%E6%9D%BF#.E5.87.86.E5.88.99" target="_blank" rel="noopener">准则(criteria)</a></li><li><a href="https://minecraft-zh.gamepedia.com/%E8%AE%B0%E5%88%86%E6%9D%BF#.E6.98.BE.E7.A4.BA.E4.BD.8D.E7.BD.AE" target="_blank" rel="noopener">显示位置(DisplaySlot)</a></li></ul><p><strong>若读者有制作CB的经验，那么上方的基本概念可以跳过</strong></p><p>在有了上方对记分板的基本概念后，我们来查询一下Bukkit API中对Scoreboard的包装</p><p><a href="http://docs.zoyn.top/bukkitapi/1.12.2/org/bukkit/scoreboard/Scoreboard.html" target="_blank" rel="noopener">1.12.2版本</a> | <a href="https://www.mcbbs.net/plugin.php?id=link_redirect&target=https%3A%2F%2Fbukkit.windit.net%2Fjavadoc%2Findex.html%3Forg%2Fbukkit%2Fscoreboard%2Fpackage-summary.html">1.13+版本</a><br><a href="https://www.mcbbs.net/plugin.php?id=link_redirect&target=https%3A%2F%2Fhub.spigotmc.org%2Fjavadocs%2Fspigot%2Findex.html%3Forg%2Fbukkit%2Fscoreboard%2Fpackage-summary.html">Spigot最新版本</a></p><p><em>我吹爆中文BukkitAPI</em></p><p>可以在上方的Javadoc的查询知道，在Bukkit当中，所有关于Scoreboard的操作都被放到 <em>org.bukkit.scoreboard</em> 包下了，之后我们就来看一下，要怎么正确的使用一个记分板吧</p><p><strong><em>在阅读教程之前我强烈建议先看一看中文MinecraftWiki再来阅读本文</em></strong></p><h3 id="使用Scoreboard进行展示数据给玩家"><a href="#使用Scoreboard进行展示数据给玩家" class="headerlink" title="使用Scoreboard进行展示数据给玩家"></a>使用Scoreboard进行展示数据给玩家</h3><p>接下来我们就来看看如何进行操作<br>首先我们需要的是ScoreboardManager这个接口的对象，怎么获取呢？我可以通过下方代码实现</p><pre><code>ScoreboardManager manager = Bukkit.getScoreboardManager();</code></pre><p>在Bukkit这个静态类中，BukkitAPI已经帮我们造好了轮子，我们可以直接使用<br>接下来我们就需要得到一个叫 <strong>Scoreboard</strong> 接口的对象，我们可以通过manager里的方法来进行获得</p><pre><code>Scoreboard scoreboard = manager.getNewScoreboard();</code></pre><blockquote><p><strong>为什么要用 getNewScoreboard() 呢？</strong><br>因为这样我们只会<strong>新建</strong>出一个Scoreboard，这个Scoreboard是不会受原版指令的限制的Scoreboard</p></blockquote><p>之后我们需要新建一个计分项，也就是Objective，接下来看我的操作</p><pre><code>Objective objective = scoreboard.registerNewObjective(&quot;内部名字&quot;, &quot;dummy&quot;, &quot;§a我是展示名~~&quot;);</code></pre><p>首先我们看上面的<strong>三个参数</strong>，name，criteria，displayName，那么对应过来的就是计分项的内部名字和准则与展示名</p><ul><li>内部名字: 用于scoreboard.getObjective()时填入, 可直接获取Objective</li><li>准则: 此 Objective 的准则，表示只能通过插件修改分数</li><li>展示名: 也就是计分板头上的那个标题，比如下图的 Scoreboard 就是展示名<br><img src="https://upload-images.jianshu.io/upload_images/8109631-b081ebf88bdaebe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="Scoreboard.png"></li></ul><blockquote><p><strong>为什么要写 dummy 呢？</strong><br>因为 dummy 型的准则<strong><em>更适合于</em></strong>插件开发, 并且它不会被玩家死亡或击杀变动</p></blockquote><p>之后我们给Objective设置显示的位置</p><pre><code>objective.setDisplaySlot(DisplaySlot.SIDEBAR);</code></pre><p>我们来解释一下这个显示位置的问题：<br>DisplaySlot这个枚举列举了所有Objective可以存在的地方</p><ul><li>PLAYER_LIST （玩家Tab里）</li><li>SIDEBAR（侧边栏）</li><li>BELOW_NAME （玩家头上NameTag的下面）</li></ul><p>那么接下来我们就要往 Objective 里添加Score了</p><pre><code>Score score = objective.getScore(&quot;内容&quot;);score.setScore(12345);</code></pre><p>之后我们就可以给玩家设置上我们的Scoreboard<br><strong><em>（如果没有做这一步，并且事先也未给玩家设置Scoreboard的话，会导致无法显示与使用!）</em></strong></p><pre><code>Player player = 我也不知道这个player要从哪引用;player.setScoreboard(scoreboard);</code></pre><p><strong>完整代码</strong></p><pre><code>ScoreboardManager manager = Bukkit.getScoreboardManager();// 建立新ScoreboardScoreboard scoreboard = manager.getNewScoreboard();// 注册新的记分项Objective objective = scoreboard.registerNewObjective(&quot;内部名字&quot;, &quot;dummy&quot;, &quot;§a我是展示名~~&quot;);// 设置记分项展示位置objective.setDisplaySlot(DisplaySlot.SIDEBAR);// 给记分项增加 内容与对应的分数Score score = objective.getScore(&quot;内容&quot;);score.setScore(12345);// 设置计分板Player player = 我也不知道这个player要从哪引用;player.setScoreboard(scoreboard);</code></pre><p>具体效果:<br><img src="https://upload-images.jianshu.io/upload_images/8109631-6f90b667d3ebd6e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="啦啦啦"></p><h3 id="制作无闪计分板"><a href="#制作无闪计分板" class="headerlink" title="制作无闪计分板"></a>制作无闪计分板</h3><p><strong>问题引入：</strong><br>那么在经过了上面的实例之后我相信，大部分人都已经学会了如何简易的给玩家设置计分板，但是当我们在做一些<strong>动态的</strong>计分板的时候，会出现<strong>闪烁</strong>的问题，那么这是怎么出现的呢？<br>就拿我们刚才的代码来说，如果我们想更改计分板的内容，我们只能通过</p><pre><code>scoreboard.resetScores(&quot;内容&quot;);</code></pre><p>这样的方式才能删除一个Score，那么就有人说了</p><ol><li><p>诶呀为什么不直接clear或者reset呢？<br>我也想啊，只可惜Minecraft的计分板就是这么设计的，所以我们如果想更换内容就得先 <strong><em>resetScores()</em></strong> 之后再 <strong><em>objective.getScore()</em></strong> 才能进行更换</p></li><li><p>然后这时候又有人说了，那我重新的getNewScoreboard不就好了吗？<br>诶呀，你自己看看我们上面所写的代码，我们还要注册个新的Objective，之后设置一大堆东西，然后才能开始设置Score，这里面的<strong>实现早已就产生了上百的ms</strong>，所以这个方法会导致闪烁的问题</p></li><li><p>然后这个时候lz就说了，诶呀为什么不用resetScores填入内容之后，再getScore来设置呢？<br>诶呀，这样的话其实还是会导致在 resetScores 的时候出现部分闪屏的内容，属于<strong><em>假无闪！</em></strong>，具体思路是：<br><del>1. 首先我们在 objective.getScore 时顺便将内容存入一个作为cache的List中</del><br><del>2. 在下一次我们想要修改时，遍历这个 cache 的List，之后resetScores</del><br><del>3. 最后再使用 objective.getScore 添加数据</del></p></li></ol><p>那么这时候我们就会出现一个问题，<strong>既然我们不能用 resetScores，那么我们应当怎么写呢？</strong><br>这里我要感谢 <a href="https://www.mcbbs.net/forum.php?mod=redirect&goto=findpost&ptid=897858&pid=17019573" target="_blank" rel="noopener">#6楼</a> 提示给我的方法，所以这里我对解决方案进行更改</p><p>那么这里是我的解决方案:<br>我们通过使用Team的特性来写，Team这个东西其实是，在下面的一部分，但是为了做出无闪的效果，这里提前说一下思路就行</p><ol><li>在Team中有setPrefix和setSuffix的方法，通过这两个方法我们可以<strong>直接修改前后缀</strong></li><li>如果我们新建15个队伍，然后给每个队伍只addEntry(name)，我们为了做出name不显示的效果，我们可以使用颜色代码 §X 的形式做出不显示的效果来实现</li><li>之后我们给每个队伍设置不同的prefix和suffix，这样就可以达到不通过resetScore来设置内容</li></ol><p>我们来看下面的实例</p><h5 id="实例：制作一个实时显示时间的计分板"><a href="#实例：制作一个实时显示时间的计分板" class="headerlink" title="实例：制作一个实时显示时间的计分板"></a>实例：制作一个实时显示时间的计分板</h5><pre><code>import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;import org.bukkit.Bukkit;import org.bukkit.ChatColor;import org.bukkit.entity.Player;import org.bukkit.plugin.Plugin;import org.bukkit.scheduler.BukkitTask;import org.bukkit.scoreboard.DisplaySlot;import org.bukkit.scoreboard.Objective;import org.bukkit.scoreboard.Scoreboard;import org.bukkit.scoreboard.Team;import com.google.common.collect.Lists;public class MyScoreboard {    private Scoreboard scoreboard;    private Objective objective;    private String title;    private Player player;    private boolean isRun;    private SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    private SimpleDateFormat format2 = new SimpleDateFormat(&quot;HH:mm:ss&quot;);    // 用作runnable的主类实例    private Plugin plugin;    /**     * 用于保存所有的Team     */    private List&lt;Team&gt; timers;    private BukkitTask task;    public MyScoreboard(Plugin plugin, Player player, String title) {        this.scoreboard = Bukkit.getScoreboardManager().getNewScoreboard();        this.title = title;        this.objective = scoreboard.registerNewObjective(player.getName(), &quot;dummy&quot;, this.title.replace(&quot;&amp;&quot;, &quot;§&quot;));        objective.setDisplaySlot(DisplaySlot.SIDEBAR);        this.player = player;        this.isRun = false;        this.plugin = plugin;        timers = Lists.newArrayList();    }    public void startShowing() {        // 判断是否已经在运行        if (isRun) {            return;        }        if (player == null || !player.isOnline()) {            return;        }        isRun = true;        player.setScoreboard(scoreboard);        // 用于保存前15位的内容        List&lt;String&gt; tempList = Lists.newArrayList();        for (int i = 0; i &lt;= 15; i++) {            tempList.add(&quot;§&quot; + ChatColor.values()[i].getChar());        }        for (int i = 0; i &lt;= 15; i++) {            // 注册Team时使用 数字的形式就行            Team timer = scoreboard.registerNewTeam(&quot;&quot; + i);            // addEntry只是作为一个标识符, 用于getScore时的识别            timer.addEntry(tempList.get(i));            // getScore 刚才的标识符            objective.getScore(tempList.get(i)).setScore(i);            timers.add(timer);        }        task = Bukkit.getScheduler().runTaskTimer(plugin, () -&gt; {            if (!isRun) {                return;            }            for (int i = 0; i &lt; timers.size(); i++) {                Team timer = timers.get(i); // 获取每个Team                Date date = new Date();                // 设置前缀                timer.setPrefix(tempList.get(i) + format.format(date));                // 设置后缀                timer.setSuffix(tempList.get(i) + &quot; &quot; + format2.format(date));            }        }, 0L, 20L);    }    public void turnOff() {        isRun = false;        task.cancel();    }}</code></pre><p>具体效果:<img src="https://upload-images.jianshu.io/upload_images/8109631-8e0c7b5277d8f3b7.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="无闪计分板"></p><p><del><strong><em>请不要在意时间，是星空的测试机的锅，我是早睡早起的四好青年</em></strong></del></p><h3 id="如何使用Minecraft自带的Team"><a href="#如何使用Minecraft自带的Team" class="headerlink" title="如何使用Minecraft自带的Team"></a>如何使用Minecraft自带的Team</h3><p>Team这个东西其实是<strong>比较适合Minecraft的</strong>（不然干嘛是Mojang自己做的），因为这个东西你可以设置很多内容，比如说</p><ul><li>COLLISION_RULE（<strong>体积碰撞</strong>）：你可以设置相同队伍可以没有体积碰撞</li><li>DEATH_MESSAGE_VISIBILITY（<strong>死亡信息可见性</strong>）：你可以设置相同队伍才可以看见玩家的死亡信息</li><li>NAME_TAG_VISIBILITY（<strong>玩家头顶名字可见性</strong>）：你可以设置相同队伍才可以看见头顶名字</li><li>CanSeeFriendlyInvisibles（<strong>是否可以看到自己队伍的人隐身</strong>）</li><li>AllowFriendlyFire（<strong>是否可以友军开火</strong>）<br><del>再也不需要EntityDamageByEntityEvent了!</del></li><li>Color 队伍颜色</li><li>Prefix 队伍前缀，可以直接设置到玩家的NameTag上</li><li>Suffix 队伍后缀，可以直接设置到玩家的NameTag上</li></ul><p><strong>版本变换</strong>：其实在1.13的版本之后Team就更改了一下，主要的就是更改了Prefix和Suffix字符还有DisplayName的长度的限制，因为1.13以后的版本，这些内容改用json来储存</p><p>1.13以前 设置Prefix和Suffix只能在16个字符以内<br>而在1.13以后，设置Prefix和Suffix可以在64个字符以内了<br>并且DisplayName也从32个字符长度增长到128个字符</p><p>此外对于Team就没有更多的API更新了</p><p>那么接下来我们就来看看Team是如何使用的<br>首先我们需要建立一个新的Scoreboard</p><pre><code>Scoreboard teamScoreboard = Bukkit.getScoreboardManager().getNewScoreboard();</code></pre><p>之后我们来新建两个队伍，<strong>红队</strong>和<strong>蓝队</strong></p><pre><code>Team redTeam = teamScoreboard.registerNewTeam(&quot;RED&quot;);Team blueTeam = teamScoreboard.registerNewTeam(&quot;BLUE&quot;);</code></pre><p>在上面的代码我们要注意，RED和BLUE其实是队伍的<strong>内部名字，不做显示用</strong></p><p>之后我们来给它设置<strong>别的内容</strong></p><pre><code>// 设置显示名redTeam.setDisplayName(&quot;红队&quot;);blueTeam.setDisplayName(&quot;蓝队&quot;);// 设置队伍颜色redTeam.setColor(ChatColor.RED);blueTeam.setColor(ChatColor.BLUE);// 对于自己的队伍进行NameTag显示, 而对其他队伍关闭 -&gt; 制作出类似吃鸡队友的感觉// 这里的FOR_OTHER_TEAM表示的意思是只对其他队伍 关闭redTeam.setOption(Option.NAME_TAG_VISIBILITY, OptionStatus.FOR_OTHER_TEAMS);blueTeam.setOption(Option.NAME_TAG_VISIBILITY, OptionStatus.FOR_OTHER_TEAMS);// 对于自己的队伍开启防碰撞体积, 而对其他队伍开启体积碰撞// 这里的FOR_OWN_TEAM表示的意思是只对本队 关闭redTeam.setOption(Option.COLLISION_RULE, OptionStatus.FOR_OWN_TEAM);blueTeam.setOption(Option.COLLISION_RULE, OptionStatus.FOR_OWN_TEAM);// 设置同队可看见隐身redTeam.setCanSeeFriendlyInvisibles(true);blueTeam.setCanSeeFriendlyInvisibles(true);// 取消队伤redTeam.setAllowFriendlyFire(false);blueTeam.setAllowFriendlyFire(false);// 设置前缀redTeam.setPrefix(&quot;§c红队 - &quot;);blueTeam.setPrefix(&quot;§8蓝队 - &quot;);</code></pre><p>之后我们就建立了两个Team，之后我们得需要给他们增加玩家</p><pre><code>redTeam.addEntry(&quot;Zoyn&quot;);blueTeam.addEntry(&quot;Alex&quot;);</code></pre><p>我们在上方的代码中，<br>给<strong>红队</strong>添加了一名队员, Zoyn<br>给<strong>蓝队</strong>添加了一名队员, Alex</p><p>这里要注意的是，给队伍增加队员不是调用 <strong><em>addPlayer(OfflinePlayer player)</em></strong> 这个已经弃用的方法，因为你放在Team里的可以<strong>不只是</strong>Player，所以我们只用放入玩家名就好  </p><p>之后我们给这两个队员设置好Scoreboard（<strong>如果没有做这个操作，可能会导致不显示！</strong>）</p><pre><code>Player zoyn = ?Player alex = ?zoyn.setScoreboard(teamScoreboard);alex.setScoreboard(teamScoreboard);</code></pre><p><strong>完整代码：</strong></p><pre><code>Scoreboard teamScoreboard = Bukkit.getScoreboardManager().getNewScoreboard();Team redTeam = teamScoreboard.registerNewTeam(&quot;RED&quot;);Team blueTeam = teamScoreboard.registerNewTeam(&quot;BLUE&quot;);// 设置显示名redTeam.setDisplayName(&quot;红队&quot;);blueTeam.setDisplayName(&quot;蓝队&quot;);// 设置队伍颜色redTeam.setColor(ChatColor.RED);blueTeam.setColor(ChatColor.BLUE);// 对于自己的队伍进行NameTag显示, 而对其他队伍关闭 -&gt; 制作出类似吃鸡队友的感觉// 这里的FOR_OTHER_TEAM表示的意思是只对其他队伍 关闭redTeam.setOption(Option.NAME_TAG_VISIBILITY, OptionStatus.FOR_OTHER_TEAMS);blueTeam.setOption(Option.NAME_TAG_VISIBILITY, OptionStatus.FOR_OTHER_TEAMS);// 对于自己的队伍开启防碰撞体积, 而对其他队伍开启体积碰撞// 这里的FOR_OWN_TEAM表示的意思是只对本队 关闭redTeam.setOption(Option.COLLISION_RULE, OptionStatus.FOR_OWN_TEAM);blueTeam.setOption(Option.COLLISION_RULE, OptionStatus.FOR_OWN_TEAM);// 设置同队可看见隐身redTeam.setCanSeeFriendlyInvisibles(true);blueTeam.setCanSeeFriendlyInvisibles(true);// 取消队伤redTeam.setAllowFriendlyFire(false);blueTeam.setAllowFriendlyFire(false);// 设置前缀redTeam.setPrefix(&quot;§c红队-&quot;);blueTeam.setPrefix(&quot;§9蓝队-&quot;);redTeam.addEntry(&quot;Zoyn&quot;);blueTeam.addEntry(&quot;Alex&quot;);Player zoyn = ?Player alex = ?zoyn.setScoreboard(teamScoreboard);alex.setScoreboard(teamScoreboard);</code></pre><p><strong>实际效果：</strong><br>Zoyn视角：<img src="https://upload-images.jianshu.io/upload_images/8109631-0590a76d8f544b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="Zoyn"><br>Alex视角: <img src="https://upload-images.jianshu.io/upload_images/8109631-5ae8184f2033713d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="Alex"></p><p>当他们两者在同一队伍时<img src="https://upload-images.jianshu.io/upload_images/8109631-7eec48266e91b4e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="同一队伍"></p><h4 id="之后为了方便读者测试，我写了一个测试类来给读者测试"><a href="#之后为了方便读者测试，我写了一个测试类来给读者测试" class="headerlink" title="之后为了方便读者测试，我写了一个测试类来给读者测试"></a>之后为了方便读者测试，我写了一个测试类来给读者测试</h4><p>使用方法,<br>1.注册指令 teams （当然你也可以自己改）<br>2.reload之后第一次输入请输入 /teams init 进行队伍初始化<br>3.在指令中的队伍名，只有 RED 和 BLUE </p><p>实例：一个使用Scoreboard#Team的内容来写一个组队系统</p><pre><code>import org.bukkit.Bukkit;import org.bukkit.ChatColor;import org.bukkit.command.Command;import org.bukkit.command.CommandExecutor;import org.bukkit.command.CommandSender;import org.bukkit.entity.Player;import org.bukkit.scoreboard.Scoreboard;import org.bukkit.scoreboard.Team;import org.bukkit.scoreboard.Team.Option;import org.bukkit.scoreboard.Team.OptionStatus;public class TeamCommand implements CommandExecutor {    private Scoreboard teamScoreboard;    @Override    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {        if (cmd.getName().equalsIgnoreCase(&quot;teams&quot;)) {            if (args.length == 0) {                sender.sendMessage(&quot;/teams init 初始化&quot;);                sender.sendMessage(&quot;/teams list 列出所有队伍&quot;);                sender.sendMessage(&quot;/teams set &lt;玩家名&gt; &lt;队伍名&gt; 将玩家的队伍进行设置&quot;);                sender.sendMessage(&quot;/teams prefix &lt;队伍名&gt; &lt;前缀名&gt; 将玩家的队伍进行前缀的设置&quot;);                sender.sendMessage(&quot;/teams suffix &lt;队伍名&gt; &lt;前缀名&gt; 将玩家的队伍进行前缀的设置&quot;);                return true;            }            if (args[0].equalsIgnoreCase(&quot;init&quot;)) {                teamScoreboard = Bukkit.getScoreboardManager().getNewScoreboard();                Team redTeam = teamScoreboard.registerNewTeam(&quot;RED&quot;);                Team blueTeam = teamScoreboard.registerNewTeam(&quot;BLUE&quot;);                // 设置显示名                redTeam.setDisplayName(&quot;红队&quot;);                blueTeam.setDisplayName(&quot;蓝队&quot;);                // 设置队伍颜色                redTeam.setColor(ChatColor.RED);                blueTeam.setColor(ChatColor.BLUE);                // 对于自己的队伍进行NameTag显示, 而对其他队伍关闭 -&gt; 制作出类似吃鸡队友的感觉                // 这里的FOR_OTHER_TEAM表示的意思是只对其他队伍 关闭                redTeam.setOption(Option.NAME_TAG_VISIBILITY, OptionStatus.FOR_OTHER_TEAMS);                blueTeam.setOption(Option.NAME_TAG_VISIBILITY, OptionStatus.FOR_OTHER_TEAMS);                // 对于自己的队伍开启防碰撞体积, 而对其他队伍开启体积碰撞                // 这里的FOR_OWN_TEAM表示的意思是只对本队 关闭                redTeam.setOption(Option.COLLISION_RULE, OptionStatus.FOR_OWN_TEAM);                blueTeam.setOption(Option.COLLISION_RULE, OptionStatus.FOR_OWN_TEAM);                // 由于只做演示, 所以这里的sender我直接强转得到                Player player = (Player) sender;                player.setScoreboard(teamScoreboard);                sender.sendMessage(&quot;§a操作成功!&quot;);                return true;            }            if (args[0].equalsIgnoreCase(&quot;list&quot;)) {                teamScoreboard.getTeams().forEach(team -&gt; {                    sender.sendMessage(&quot;名字: &quot; + team.getName());                    sender.sendMessage(&quot;展示名: &quot; + team.getDisplayName());                    sender.sendMessage(&quot;已有队员: &quot;);                    team.getEntries().forEach(player -&gt; {                        sender.sendMessage(&quot; - &quot; + player);                    });                    sender.sendMessage(&quot;=====================&quot;);                });                sender.sendMessage(&quot;§a操作成功!&quot;);                return true;            }            if (args[0].equalsIgnoreCase(&quot;set&quot;)) {                Player entry = Bukkit.getPlayer(args[1]);                if (entry == null || !entry.isOnline()) {                    sender.sendMessage(&quot;玩家不在线!&quot;);                    return true;                }                Team playerTeam = teamScoreboard.getEntryTeam(entry.getName());                Team team = teamScoreboard.getTeam(args[2]);                if (playerTeam != null) {                    // 将玩家离开之前的队伍                    playerTeam.removeEntry(args[1]);                }                // 将玩家加入选定的队伍                team.addEntry(args[1]);                // 对选中的人设置计分板, 不然会导致无法显示的问题                entry.setScoreboard(teamScoreboard);                sender.sendMessage(&quot;§a操作成功!&quot;);                return true;            }            if (args[0].equalsIgnoreCase(&quot;prefix&quot;)) {                Team team = teamScoreboard.getTeam(args[1]);                team.setPrefix(ChatColor.translateAlternateColorCodes(&#39;&amp;&#39;, args[2]));                sender.sendMessage(&quot;§a操作成功!&quot;);                return true;            }            if (args[0].equalsIgnoreCase(&quot;suffix&quot;)) {                Team team = teamScoreboard.getTeam(args[1]);                team.setSuffix(ChatColor.translateAlternateColorCodes(&#39;&amp;&#39;, args[2]));                sender.sendMessage(&quot;§a操作成功!&quot;);                return true;            }        }        return true;    }</code></pre><p>这就是BukkitAPI中对 org.bukkit.scoreboard 包的内的所有内容，如果你有相关问题可以回复，一起交流 —— 一个本科人</p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好, 世界</title>
    <link href="/2020/03/29/%E4%BD%A0%E5%A5%BDZoyn/"/>
    <url>/2020/03/29/%E4%BD%A0%E5%A5%BDZoyn/</url>
    
    <content type="html"><![CDATA[<p>新搭建的博客嗷, 测试一下啦啦啦</p><pre><code>print(&quot;Hello World!&quot;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>随手发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的MC特效(六 | 坐标系的旋转)</title>
    <link href="/2020/03/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E5%85%AD)/"/>
    <url>/2020/03/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E5%85%AD)/</url>
    
    <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h4><ul><li>导读</li><li>Location点的旋转</li><li>坐标系的修正与在玩家背部建立坐标系</li><li>制作简易翅膀<h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4>导读<br>本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)<br>本教程使用的 <strong>PaperSpigot1.12.2-R0.1-SNAPSHOT</strong> 核心<br>在阅读之前请确保你具有<strong>高中数学必修4</strong>和和<strong>Java基础</strong>的知识</li></ul><p>&lt;To初中生&gt;: 如果你是初中的话，别慌，你有趋向的概念就可以读懂本教程(应该吧…)<br>&lt;To高中生&gt;: 如果你还未学到关于上面的那本书，别慌学到了再来看也行233 (雾<br>&lt;To大学生&gt;: 没什么好说的…</p><hr><h4 id="Location点的旋转"><a href="#Location点的旋转" class="headerlink" title="Location点的旋转"></a>Location点的旋转</h4><p>首先我们引入<strong>平面上点围绕另一个点进行旋转</strong>的公式 (数学上)<br>平面中，一个点(x,y)绕任意点(x0,y0)逆时针旋转a度后的坐标</p><pre><code>dx = (x - x0)*cos(a) - (y - y0)*sin(a) + x0 ;dy = (x - x0)*sin(a) + (y - y0)*cos(a) + y0 ;</code></pre><p>那么我们写入代码看看是怎么样的</p><pre><code>/** * 在二维平面上利用给定的中心点逆时针旋转一个点 *  * @param location 待旋转的点 * @param angle    旋转角度 * @param point    中心点 * @return {@link Location}*/public static Location rotateLocationAboutPoint(Location location, double angle, Location point) {    double radians = Math.toRadians(angle);    double dx = location.getX() - point.getX();    double dz = location.getZ() - point.getZ();    double newX = dx * Math.cos(radians) - dz * Math.sin(radians) + point.getX();    double newZ = dz * Math.cos(radians) + dx * Math.sin(radians) + point.getZ();    return new Location(location.getWorld(), newX, location.getY(), newZ);}</code></pre><p>总所周知，在mc坐标内，玩家走动的二维平面，其实是<strong>影响x轴和z轴</strong>的内容，所以我们上方的代码就套用x，y</p><h4 id="坐标系的修正与在玩家背部建立坐标系"><a href="#坐标系的修正与在玩家背部建立坐标系" class="headerlink" title="坐标系的修正与在玩家背部建立坐标系"></a>坐标系的修正与在玩家背部建立坐标系</h4><p>在我们之前的教程中，我们都会发现，我们在做一些让特效出现在<strong><em>玩家面前</em></strong>时，会出现<strong>特效</strong>出现在另外一边，这其实就是我们没有经过<strong>玩家朝向的修正</strong>，而发生的情况，比如下面这一张图<br><img src="https://upload-images.jianshu.io/upload_images/8109631-786f3cf0345d9fda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="爱心.png"></p><p>那么我们可以重新建立一个<strong>修正过后的</strong>坐标系，用的方法就是利用Location点的旋转</p><pre><code>import org.bukkit.Location;/** * 自动修正在平面上的粒子朝向 *  * @author Zoyn */public class PlayerFixedCoordinate {    private Location zeroDot;    private double rotateAngle;    public PlayerFixedCoordinate(Location playerLocation) {        // 旋转的角度        rotateAngle = playerLocation.getYaw();        zeroDot = playerLocation.clone();        zeroDot.setPitch(0);        // 重设仰俯角, 防止出现仰头后旋转角度不正确的问题    }    public Location getZeroDot() {        return zeroDot;    }    public Location newLocation(double x, double z) {        return rotateLocationAboutPoint(zeroDot.clone().add(-x, 0, z), rotateAngle, zeroDot);    }        /**     * 在二维平面上利用给定的中心点逆时针旋转一个点     *      * @param location 待旋转的点     * @param angle    旋转角度     * @param point    中心点     * @return {@link Location}     */    public static Location rotateLocationAboutPoint(Location location, double angle, Location point) {        double radians = Math.toRadians(angle);        double dx = location.getX() - point.getX();        double dz = location.getZ() - point.getZ();        double newX = dx * Math.cos(radians) - dz * Math.sin(radians) + point.getX();        double newZ = dz * Math.cos(radians) + dx * Math.sin(radians) + point.getZ();        return new Location(location.getWorld(), newX, location.getY(), newZ);    }}</code></pre><p>首先我们来分析这个类是怎么写的，首先我们要旋转一个点，就需要旋转的角度，那么这时候 <strong><em>location</em></strong> 里的 <strong><em>yaw</em></strong> 就可以帮助我们完成这个工作，所以我在构造器里将 <strong><em>yaw</em></strong> 记录为 <strong><em>rotateAngle</em></strong> </p><p>之后我们看<strong><em>newLocation</em></strong>这个方法，需要填入两个参数分别是 <strong><em>x, y</em></strong> （为了方便理解，我其实直接将其设计为数学上的平面直角坐标系（右手坐标系））</p><p>而我们在看</p><pre><code>zeroDot.clone().add(-x, 0, z)</code></pre><p>这行代码, 首先它是 <strong><em>rotateLocationAboutPoint</em></strong> 方法里的<strong>待旋转的点</strong>，那么我们为什么要add呢？<br>因为啊, <strong><em>zeroDot</em></strong> 就是我们坐标系的原点，经过add之后就可以得到新的x，y了，</p><blockquote><p>比如说，zeroDot是(0, 0)，方法填入3, 2, 那么add完之后就得到 (3, 2) 这个点</p></blockquote><p><strong>那么为什么是-x呢？？？</strong><br>因为啊，在Mc中的坐标系是遵循左手坐标系来设计的，所以它的x轴我们要乘以一个-1才能按照我们平常理解的右手坐标系来绘图</p><p>之后我们套用上这个修复过的坐标系来看看效果<br><img src="https://upload-images.jianshu.io/upload_images/8109631-2d53f06a77171156.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="jdfw3.gif"><br>完整代码:</p><pre><code>Player player = ........PlayerFixedCoordinate coordinate = new PlayerFixedCoordinate(player.getLocation());double radius = 10;for (double t = -1; t &lt;= 1; t += 0.001) {    double x = radius * Math.sin(t) * Math.cos(t) * Math.log(Math.abs(t));    double y = radius * Math.sqrt(Math.abs(t)) * Math.cos(t);    Location loc = coordinate.newLocation(x, y);    loc.getWorld().spawnParticle(Particle.FIREWORKS_SPARK, loc, 1, 0, 0, 0, 0);}</code></pre><p>下面分享一个<strong><em>PlayerBackCoordinate</em></strong>为了让读者能够举一反三，希望读者能够<strong><em>自行添加 z 轴的变化（思考：z轴的变化在右手坐标系中是如何变化，又应该如何将其转换至MC坐标系内）</em></strong></p><p>绘图思考可以参照这张图：<br><img src="https://upload-images.jianshu.io/upload_images/8109631-9ffc52cc57748de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="PlayerBackCoordinate的思考"></p><pre><code>import org.bukkit.Location;/** * 将玩家背后转换为一个平面直角坐标系 *  * @author Zoyn */public class PlayerBackCoordinate {    private Location zeroDot;    private double rotateAngle;    public PlayerBackCoordinate(Location playerLocation) {        // 旋转的角度        rotateAngle = playerLocation.getYaw();        zeroDot = playerLocation.clone();        zeroDot.setPitch(0); // 重设仰俯角        zeroDot.add(zeroDot.getDirection().multiply(-0.3)); // 使原点与玩家有一点点距离    }    public Location getZeroDot() {        return zeroDot;    }    public Location newLocation(double x, double y) {        return rotateLocationAboutPoint(zeroDot.clone().add(-x, y, 0), rotateAngle, zeroDot);    }        /**     * 在二维平面上利用给定的中心点逆时针旋转一个点     *      * @param location 待旋转的点     * @param angle    旋转角度     * @param point    中心点     * @return {@link Location}     */    public static Location rotateLocationAboutPoint(Location location, double angle, Location point) {        double radians = Math.toRadians(angle);        double dx = location.getX() - point.getX();        double dz = location.getZ() - point.getZ();        double newX = dx * Math.cos(radians) - dz * Math.sin(radians) + point.getX();        double newZ = dz * Math.cos(radians) + dx * Math.sin(radians) + point.getZ();        return new Location(location.getWorld(), newX, location.getY(), newZ);    }}</code></pre><p>上方代码的使用：实例1：在玩家后背绘制一个圆</p><pre><code>Player player = (Player) sender;PlayerBackCoordinate coordinate = new PlayerBackCoordinate(player.getLocation().add(0, 1.6D, 0));for (int angle = 0; angle &lt; 360; angle++) {    double radians = Math.toRadians(angle);    double x = Math.cos(radians);    double y = Math.sin(radians);    Location loc = coordinate.newLocation(x, y);    loc.getWorld().spawnParticle(Particle.FLAME, loc, 1, 0, 0, 0, 0);}</code></pre><p>具体效果：<br><img src="https://upload-images.jianshu.io/upload_images/8109631-630f0e23257a8242.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="背后的火圈"></p><h4 id="制作简易翅膀"><a href="#制作简易翅膀" class="headerlink" title="制作简易翅膀"></a>制作简易翅膀</h4><p>不说这么多，直接上代码好吧，用的就是上面的代码</p><pre><code>Player player = (Player) sender;PlayerBackCoordinate coordinate = new PlayerBackCoordinate(player.getLocation().add(0, 1.5D, 0));for (double angle = 0; angle &lt;= 135; angle++) {    double x = Math.toRadians(angle);    double y = Math.sin(2 * x);    Location loc = coordinate.newLocation(x, y);    loc.getWorld().spawnParticle(Particle.VILLAGER_HAPPY, loc, 1, 0, 0, 0, 0);}for (double angle = -135; angle &lt;= 0; angle++) {    double x = Math.toRadians(angle);    double y = Math.cos((2 * x) + (Math.PI / 2));    Location loc = coordinate.newLocation(x, y);    loc.getWorld().spawnParticle(Particle.VILLAGER_HAPPY, loc, 1, 0, 0, 0, 0);}coordinate = new PlayerBackCoordinate(player.getLocation().add(0, 1, 0));double radius = 0;for (double angle = 0; angle &lt;= 3 * 360; angle++) {    double radians = Math.toRadians(angle);    double x = radius * Math.cos(radians);    double y = radius * Math.sin(radians);    Location loc = coordinate.newLocation(x, y);    loc.getWorld().spawnParticle(Particle.FIREWORKS_SPARK, loc, 1, 0, 0, 0, 0);    radius += 0.001;}</code></pre><p>具体效果:<br><img src="https://upload-images.jianshu.io/upload_images/8109631-f1633dad8c40835b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="函数翅膀"></p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
      <tag>数学</tag>
      
      <tag>MC特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的MC特效(五 | BukkitRunnable与粒子特效)</title>
    <link href="/2019/01/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%BA%94)/"/>
    <url>/2019/01/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h4><ul><li>导读</li><li>BukkitRunnable之逐渐在玩家身旁出现的粒子<h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4>导读<br>本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)<br>本教程使用的 <strong>Spigot1.10.2-R0.1-SNAPSHOT</strong> 核心<br>在阅读之前请确保你具有<strong>高中数学必修4</strong>和和<strong>Java基础</strong>的知识</li></ul><p>&lt;To初中生&gt;: 如果你是初中的话，别慌，你有趋向的概念就可以读懂本教程(应该吧…)<br>&lt;To高中生&gt;: 如果你还未学到关于上面的那本书，别慌学到了再来看也行233 (雾<br>&lt;To大学生&gt;: 没什么好说的…</p><hr><h4 id="BukkitRunnable之逐渐在玩家身旁出现的粒子"><a href="#BukkitRunnable之逐渐在玩家身旁出现的粒子" class="headerlink" title="BukkitRunnable之逐渐在玩家身旁出现的粒子"></a>BukkitRunnable之逐渐在玩家身旁出现的粒子</h4><p>如果读者还不知道这是个什么东西的话，可以通过以下几个地方进行了解<br><a href="https://docs.windit.net/Chinese_BukkitAPI/org/bukkit/scheduler/BukkitRunnable.html" target="_blank" rel="noopener">Bukkit中文文档</a> 或者 <a href="https://bukkit.windit.net/javadoc/org/bukkit/scheduler/BukkitScheduler.html" target="_blank" rel="noopener">这个</a> 还有就是我自己的 <a href="https://www.bilibili.com/video/av20352427/" target="_blank" rel="noopener">视频教程</a></p><p>首先利用BukkitRunnable的Task性质，我们可以制造一个 <strong>粒子特效逐渐渲染</strong> 的效果，而不是像以前那样一下子就渲染完毕，我们来看以下的例子</p><pre><code>public class CrownEffect extends BukkitRunnable {    /**     * 玩家     */    private Player player;    private double degree = 0;    public CrownEffect(Player player) {        this.player = player;    }    @Override    public void run() {    }}</code></pre><p>首先我们创建了一个类称之为 CrownEffect 之后我们让它继承于 BukkitRunnable，之后我们需要往run方法里写粒子的出现方式</p><pre><code>@Overridepublic void run() {    // 用于检查玩家是否不在线的情况    if (player == null || !player.isOnline()) {        cancel();    }    Location playerLocation = player.getLocation();    // 转弧度制    double radians = Math.toRadians(degree);    // 这里我写得简单了一点，我们将玩家的坐标克隆之后直接进行x, y, z的变换    // 不难看出，我们这里是想建立一个 0.3 为半径的圆，作为我们想要实现的皇冠    Location playEffectLocation = playerLocation.clone().add(0.3 * Math.cos(radians), 2D, 0.3 * Math.sin(radians));    // 粒子播放，这里我使用了类库    ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.ORANGE), playEffectLocation, 50);    // 我们只需要degree在0~360度内即可    if (degree &gt;= 360) {        degree = 0;    } else {       // 这里其实就是修改了步长为20 degree       degree += 20;    }}</code></pre><p>通过上方的代码，相信你已经可以理解我们所要实现的内容了，之后我们对这个类进行进一步的完善</p><pre><code>/** * 王冠特效 * * @author Zoyn */public class CrownEffect extends BukkitRunnable {    /**     * 玩家     */    private Player player;    private double degree = 0;    public CrownEffect(Player player) {        this.player = player;    }    @Override    public void run() {        if (player == null || !player.isOnline()) {            cancel();        }        Location playerLocation = player.getLocation();        double radians = Math.toRadians(degree);        Location playEffectLocation = playerLocation.clone().add(0.3 * Math.cos(radians), 2D, 0.3 * Math.sin(radians));        ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.ORANGE), playEffectLocation, 50);        if (degree &gt;= 360) {            degree = 0;        } else {            degree += 20;        }    }    /**     * 开启特效的方法     */    public void startEffect() {        runTaskTimer(主类的实例, 0L, 1L);    }    /**     * 关闭特效的方法     */    public void stopEffect() {        cancel();    }}</code></pre><p>调用方法</p><pre><code>CrownEffect crownEffect = new CrownEffect(player);crownEffect.startEffect();</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/8109631-f53c0c5e9fae7f1a.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="王冠"></p><h6 id="如果我们将run内的绘制算法更改一下会怎样呢？"><a href="#如果我们将run内的绘制算法更改一下会怎样呢？" class="headerlink" title="如果我们将run内的绘制算法更改一下会怎样呢？"></a>如果我们将run内的绘制算法更改一下会怎样呢？</h6><pre><code>    @Override    public void run() {        // 依然还是要判断玩家        if (player == null || !player.isOnline()) {            cancel();        }        Location playerLocation = player.getLocation().add(0, 1D, 0);        double radians = Math.toRadians(degree);        double x = 半径 * Math.cos(radians);        double y = Math.sin(radians);        double z = 半径 * Math.sin(radians);        Location playEffectLocation = playerLocation.clone().add(x, y, z);        ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.RED), playEffectLocation, 50);        if (degree &gt;= 360) {            degree = 0;        } else {            degree += 10;        }    }</code></pre><p>那么你就可以看到这样的效果<br><img src="https://upload-images.jianshu.io/upload_images/8109631-071525f1c388ab37.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="我也不懂叫什么的特效"></p><p>以上便是BukkitRunnable与粒子特效的小技巧，下面放送一个自己利用前几节课的知识加上本节的知识所写的一个特效</p><pre><code>// 会旋转的DNApublic class RotatableDNA extends BukkitRunnable {    // 原点    private Location location;    private float yaw = 0;    private double y = 0D;    public RotatableDNA(Location location) {        this.location = location.clone();    }    @Override    public void run() {        for (double degree = 0, angle = 180; degree &lt; 480; degree += 5, angle += 5) {            // 第一条            double radians = Math.toRadians(degree);            double x = Math.cos(radians);            double z = Math.sin(radians);            Vector vector = VectorUtils.getVector(location, location.clone().add(x, y, z));            Vector rotatedVector = VectorUtils.rotateVector(vector, yaw, 0);            location.add(rotatedVector);            ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.RED), location, 50);            location.subtract(rotatedVector);            // 第二条            double radians2 = Math.toRadians(angle);            double x2 = Math.cos(radians2);            double z2 = Math.sin(radians2);            Vector vector2 = VectorUtils.getVector(location, location.clone().add(x2, y, z2));            Vector rotatedVector2 = VectorUtils.rotateVector(vector2, yaw, 0);            location.add(rotatedVector2);            ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.RED), location, 20);            location.subtract(rotatedVector2);            //中间连线            if (degree % 30 == 0) {                Location pointA = location.clone().add(rotatedVector);                Location pointB = location.clone().add(rotatedVector2);                EntityNBT.buildLine(pointA, pointB);            }            y += 0.1;        }        // 将yaw设定在0~360之间进行循环        if (yaw &gt;= 360) {            yaw = 0;        } else {            yaw += 5;        }        y = 0;    }    public void startEffect() {        runTaskTimer(主类实例, 0L, 1L);    }}</code></pre><p>调用方法</p><pre><code>RotatableDNA rotatableDNA = new RotatableDNA(location);rotatableDNA.startEffect();</code></pre><p>具体效果<br><img src="https://upload-images.jianshu.io/upload_images/8109631-8985ef792a6522cb.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="period为3时"></p><p><img src="https://upload-images.jianshu.io/upload_images/8109631-acfedba833aea5fd.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="period为1时"></p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
      <tag>数学</tag>
      
      <tag>MC特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的MC特效(四 | Sin与Cos函数在Y轴上的体现)</title>
    <link href="/2019/01/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E5%9B%9B)/"/>
    <url>/2019/01/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h4><ul><li>导读</li><li>龙卷风</li><li>环绕在玩家身旁的粒子</li><li>DNA双螺旋结构<h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4>导读<br>本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)<br>本教程使用的 <strong>Spigot1.10.2-R0.1-SNAPSHOT</strong> 核心<br>在阅读之前请确保你具有<strong>高中数学必修4</strong>和和<strong>Java基础</strong>的知识</li></ul><p>&lt;To初中生&gt;: 如果你是初中的话，别慌，你有趋向的概念就可以读懂本教程(应该吧…)<br>&lt;To高中生&gt;: 如果你还未学到关于上面的那本书，别慌学到了再来看也行233 (雾<br>&lt;To大学生&gt;: 没什么好说的…</p><hr><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>首先我们来看一张图<br><img src="https://upload-images.jianshu.io/upload_images/8109631-883bd87e3ee0eaab.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="正弦余弦的空间展示"></p><p>在上图我们可以看到，Sin和Cos的图像，在Y轴上的体现就是一个螺旋，那么我们如果放到MC里要如何实现呢？</p><p>我们来看下方的代码</p><pre><code>        double radius = 1D;        double y = 0D;        for (double degree = 0; degree &lt; 360 * 2; degree++) {            double radians = Math.toRadians(degree);            double x = radius * Math.cos(radians);            double z = radius * Math.sin(radians);            location.add(x, y, z);            // 这里播放粒子使用了类库 ParticleEffect            ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.RED), location, 50);            location.subtract(x, y, z);            y += 0.005;        }</code></pre><p>看过MC特效第一章的都可以发现这其实就是一个<strong>利用参数方程绘制圆的代码</strong>，那么不同与第一章的，我<strong>在Y轴上</strong>额外加了个参数，也就是代码中的y，这个y我让其在<strong>每次循环中增加0.005个单位</strong>，那么就可以<strong>将每次粒子绘制时比之前多一个y的单位，进而形成螺旋的效果</strong></p><h4 id="龙卷风"><a href="#龙卷风" class="headerlink" title="龙卷风"></a>龙卷风</h4><p>有了前面的基础，我们可以来思考，龙卷风要怎么弄？<br>首先我们来看圆的参数方程<br><strong>x = r * cosθ</strong><br><strong>y = r * sinθ</strong><br>上方的r其实就是<strong>圆的半径</strong>，那么我们可以这么分析，如果<strong>将r变成一个可变参数</strong>，并且让它<strong>逐渐发散</strong>的话，那么不就是一个<strong>龙卷风</strong>的效果么？我们来看下方的代码</p><pre><code>        for (double radius = 0, y = 0, degree = 0; degree &lt; 360 * 4; degree++, y += 0.01, radius += 0.01) {            double radians = Math.toRadians(degree);            double x = radius * Math.cos(radians);            double z = radius * Math.sin(radians);            loc.add(x, y, z);            ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.RED), loc, 50);            loc.subtract(x, y, z);        }</code></pre><p>首先我们定义了三个变量<strong>radius y degree</strong>这三个变量分别是 <strong>半径  y轴 角度</strong>其实根据代码，不难看出，每次y单位都是自加0.01，半径也是0.01，角度就是自加1，最终的效果就会是这样的<br><img src="https://upload-images.jianshu.io/upload_images/8109631-760a3a3b19c028db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="龙卷风"></p><h4 id="环绕在玩家身旁的粒子"><a href="#环绕在玩家身旁的粒子" class="headerlink" title="环绕在玩家身旁的粒子"></a>环绕在玩家身旁的粒子</h4><p>那么在上方的<strong>龙卷风例子</strong>中，我们将y轴所加的数值设置为<strong>一个定值0.01</strong>那么我们如果<strong>将y轴所加的数值用个函数来表示</strong>会怎样呢？我们来看下方的代码</p><pre><code>double radius = 1D;for (int degree = 0; degree &lt; 360; degree++) {        double radians = Math.toRadians(degree);        double x = radius * Math.cos(radians);        double z = radius * Math.sin(radians);        double y = Math.sin(radians);        loc.add(x, y, z);        ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.RED), loc, 50);        loc.subtract(x, y, z);}for (int degree = 0; degree &lt; 360; degree++) {    double radians = Math.toRadians(degree);    double x = radius * Math.cos(radians);    double z = radius * Math.sin(radians);    double y = Math.sin(radians);    loc.add(-x, y, -z);    ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.BLUE), loc, 50);    loc.subtract(-x, y, -z);}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/8109631-be16bdb0651a2308.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="围绕粒子"></p><p>因为sin函数的特殊性，我们的y就<strong>被限制在1~-1之间</strong>移动了，所以就可以出现这么好看的一次特效了，<strong>那么蓝色的那条我们在x和z参数乘以个-1就可以达到目的</strong></p><h4 id="DNA双螺旋结构"><a href="#DNA双螺旋结构" class="headerlink" title="DNA双螺旋结构"></a>DNA双螺旋结构</h4><p>这个其实非常的简单，我直接给出代码吧</p><pre><code>public static void buildDNA(Location location) {    double radius = 1D;    double y = 0D;    for (double degree = 0, angle = 180; degree &lt; 720; degree++, angle++) {        // 第一条        double radians = Math.toRadians(degree);        double x = radius * Math.cos(radians);        double z = radius * Math.sin(radians);        location.add(x, y, z);        ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.RED), location, 50);        location.subtract(x, y, z);        // 第二条        double radians2 = Math.toRadians(angle);        double x2 = radius * Math.cos(radians2);        double z2 = radius * Math.sin(radians2);        location.add(x2, y, z2);        ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.RED), location, 50);        location.subtract(x2, y, z2);        // 中间连线，这里我打算是在可以被30整除时就进行画线        if (degree % 30 == 0) {            Location pointA = location.clone().add(x, y, z);            Location pointB = location.clone().add(x2, y, z2);            buildLine(pointA, pointB);        }        y += 0.02;   }}public static void buildLine(Location locA, Location locB) {    Vector vectorAB = locB.clone().subtract(locA).toVector();    buildLine(locA, vectorAB);}public static void buildLine(Location locA, Vector vector) {    Vector temp = vector.clone();    double vectorLength = temp.length();    temp.normalize();    for (double i = 0; i &lt; vectorLength; i += 0.1) {        Vector vectorX = temp.clone().multiply(i);        locA.add(vectorX);        ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor(Color.BLUE), locA, 50);        locA.subtract(vectorX);    }}</code></pre><p>那么出来的效果就是这样的<br><img src="https://upload-images.jianshu.io/upload_images/8109631-1810407a8bef08b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="DNA"></p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
      <tag>数学</tag>
      
      <tag>MC特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的MC特效(三 | 向量的旋转)</title>
    <link href="/2019/01/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%B8%89)/"/>
    <url>/2019/01/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h4><ul><li>导读</li><li>Yaw，Pitch，Roll与向量的旋转</li><li>利用向量旋转一个圆</li></ul><hr><h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4><p>导读<br>本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)<br>本教程使用的 <strong>Spigot1.10.2-R0.1-SNAPSHOT</strong> 核心<br>在阅读之前请确保你具有<strong>高中数学必修4</strong>和<strong>选修4-4坐标系与参数方程</strong>和<strong>Java基础</strong>的知识<br>(没有我不会解释的)</p><blockquote><p>高三时间有限，我就不解释了，请读者见谅! —— 作者 2019/1/12</p></blockquote><p>&lt;To初中生&gt;: 如果你是初中的话，别慌，你有趋向的概念就可以读懂本教程(应该吧…)<br>&lt;To高中生&gt;: 如果你还未学到关于上面的那本书，别慌学到了再来看也行233 (雾<br>&lt;To大学生&gt;: 没什么好说的…</p><hr><h4 id="Yaw，Pitch，Roll与向量的旋转"><a href="#Yaw，Pitch，Roll与向量的旋转" class="headerlink" title="Yaw，Pitch，Roll与向量的旋转"></a>Yaw，Pitch，Roll与向量的旋转</h4><p>这次我们来讲讲一些概念上的东西，在Minecraft中除了X, Y, Z之外Location还有两个量一个是Yaw一个是Pitch，这两个东西在学术上被称为<strong>欧拉角</strong>(飞机姿态角)<br>怎么理解这三个内容呢？</p><p><strong>Yaw</strong>: 我们 <strong>水平旋转</strong> 我们的头，也就是左右转头，这就是一次Yaw转动</p><p><strong>Pitch</strong>: 我们 <strong>上下旋转</strong> 我们的头，也就是上下点头，这就是一次Pitch转动</p><p><em>Roll: 这个东西在Minecraft里面没有，但是我也讲一下，大家都玩过绝地求生吧，里面的人物QE摇头时就是一次Roll转动</em></p><p><a href="https://jingyan.baidu.com/article/0bc808fc2c0e851bd485b9ce.html" target="_blank" rel="noopener">看不懂我说的可以看别的有图的</a></p><p>那么它们跟我们的向量旋转有什么关系呢？其实在Minecraft中，我们利用Yaw和Pitch就可以描述出一个Vector向量，如我们看如下的图<br><img src="https://upload-images.jianshu.io/upload_images/8109631-145349f2b1b9e144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="Minecraft Yaw 图.png"></p><p>在Minecraft当中，Yaw为0时，它表示的就是Z轴正半轴的方向，为-90°时则表示X轴正半轴的方向</p><h6 id="Pitch就是你的Steve上下看时的方向，看向天空时最大值是-90，看向地板时最大值是90，正视时就是0"><a href="#Pitch就是你的Steve上下看时的方向，看向天空时最大值是-90，看向地板时最大值是90，正视时就是0" class="headerlink" title="Pitch就是你的Steve上下看时的方向，看向天空时最大值是-90，看向地板时最大值是90，正视时就是0"></a>Pitch就是你的Steve上下看时的方向，看向天空时最大值是-90，看向地板时最大值是90，正视时就是0</h6><hr><p>概念的东西都讲完了，我们来谈谈向量的旋转，那么在数学上的话，平面向量的旋转是有直接的公式套用，或者利用矩阵也可以达到目的，<a href="https://blog.csdn.net/hjq376247328/article/details/45113563" target="_blank" rel="noopener">点我看相关资料</a></p><p>那么通过上面的资料，我们就可以得到三个方法</p><pre><code>    /**     * 将一个向量围绕X轴旋转angle个角度     *     * @param v     向量     * @param angle 角度     * @return {@link Vector}     */    public static Vector rotateAroundAxisX(Vector v, double angle) {        angle = Math.toRadians(angle);        double y, z, cos, sin;        cos = Math.cos(angle);        sin = Math.sin(angle);        y = v.getY() * cos - v.getZ() * sin;        z = v.getY() * sin + v.getZ() * cos;        return v.setY(y).setZ(z);    }    /**     * 将一个向量围绕Y轴旋转angle个角度     *     * @param v     向量     * @param angle 角度     * @return {@link Vector}     */    public static Vector rotateAroundAxisY(Vector v, double angle) {        angle = -angle;        angle = Math.toRadians(angle);        double x, z, cos, sin;        cos = Math.cos(angle);        sin = Math.sin(angle);        x = v.getX() * cos + v.getZ() * sin;        z = v.getX() * -sin + v.getZ() * cos;        return v.setX(x).setZ(z);    }    /**     * 将一个向量围绕Z轴旋转angle个角度     *     * @param v     向量     * @param angle 角度     * @return {@link Vector}     */    public static Vector rotateAroundAxisZ(Vector v, double angle) {        angle = Math.toRadians(angle);        double x, y, cos, sin;        cos = Math.cos(angle);        sin = Math.sin(angle);        x = v.getX() * cos - v.getY() * sin;        y = v.getX() * sin + v.getY() * cos;        return v.setX(x).setY(y);    }</code></pre><p>那么如果我们想用Yaw和Pitch来旋转向量应该怎么做呢？这里我直接给出方法，来自开源项目<a href="https://github.com/Slikey/EffectLib" target="_blank" rel="noopener">EffectLib</a>里的<a href="https://github.com/Slikey/EffectLib/blob/master/src/main/java/de/slikey/effectlib/util/VectorUtils.java" target="_blank" rel="noopener">VectorUtils.java</a></p><pre><code>    /**     * This handles non-unit vectors, with yaw and pitch instead of X,Y,Z angles.     * &lt;p&gt;     * Thanks to SexyToad!     * &lt;p&gt;     * 将一个非单位向量使用yaw和pitch来代替X, Y, Z的角旋转方式     *     * @param v            向量     * @param yawDegrees   yaw的角度     * @param pitchDegrees pitch的角度     * @return     */    public static final Vector rotateVector(Vector v, float yawDegrees, float pitchDegrees) {        double yaw = Math.toRadians(-1 * (yawDegrees + 90));        double pitch = Math.toRadians(-pitchDegrees);        double cosYaw = Math.cos(yaw);        double cosPitch = Math.cos(pitch);        double sinYaw = Math.sin(yaw);        double sinPitch = Math.sin(pitch);        double initialX, initialY, initialZ;        double x, y, z;        // Z_Axis rotation (Pitch)        initialX = v.getX();        initialY = v.getY();        x = initialX * cosPitch - initialY * sinPitch;        y = initialX * sinPitch + initialY * cosPitch;        // Y_Axis rotation (Yaw)        initialZ = v.getZ();        initialX = x;        z = initialZ * cosYaw - initialX * sinYaw;        x = initialZ * sinYaw + initialX * cosYaw;        return new Vector(x, y, z);    }</code></pre><h5 id="具体的证明过程我这里就不阐述了，请读者自行解决吧…"><a href="#具体的证明过程我这里就不阐述了，请读者自行解决吧…" class="headerlink" title="具体的证明过程我这里就不阐述了，请读者自行解决吧…"></a>具体的证明过程我这里就不阐述了，请读者自行解决吧…</h5><p>那么有了上面的基础我们就可以来做一个简单向量旋转的特效</p><h4 id="利用向量旋转一个圆"><a href="#利用向量旋转一个圆" class="headerlink" title="利用向量旋转一个圆"></a>利用向量旋转一个圆</h4><p>首先我们需要做个分析<br>如果我们要用向量制作一个围绕Y轴的圆可以怎么做呢？<br>我们看下方的代码</p><pre><code>public void createACircleWithVector(Location loc) {    double radius = 1D;    // 我们直接在X轴正半轴上加一个单位, 用来制作我们的第一个向量    Vector originalVector = getVector(loc, loc.clone().add(1, 0, 0));    originalVector.multiply(radius); // 圆的半径长度    for (int degree = 0; degree &lt; 360; degree++) {        // 我们将向量进行旋转        Vector vector = VectorUtils.rotateAroundAxisY(originalVector, degree);        loc.add(vector);        loc.getWorld().spawnParticle(Particle.FLAME, loc, 0);        loc.subtract(vector);    }}/** * 取第一个坐标到第二个坐标的向量 * * @param firstLocation  坐标1 * @param secondLocation 坐标2 * @return {@link Vector} */public static Vector getVector(Location firstLocation, Location secondLocation) {    return secondLocation.clone().subtract(firstLocation).toVector();}</code></pre><p>首先我们看这行代码<br><code>Vector originalVector = getVector(loc, loc.clone().add(1, 0, 0));</code><br>这行要怎么理解呢？我们看下方的图来理解一下<br><img src="https://upload-images.jianshu.io/upload_images/8109631-370b6d67e0caf43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="向量OA"></p><p>首先我们在loc的X轴上增加了一个单位也就是图中的<strong>A点</strong>，那么我们利用<strong>终点减起点</strong>来得到向量OA(看不懂的去复习<strong>MC特效二</strong>)，那么这个向量OA我们将做为我们的<strong><em>待旋转向量</em></strong></p><p>之后我们进入循环，我们<strong>假设</strong>degree是2<br><code>Vector vector = VectorUtils.rotateAroundAxisY(originalVector, 2);</code><br>那么我们调用该方法即可得到<strong>绕Y轴逆时针旋转2个角度</strong>后的向量</p><p>之后就是<strong>坐标加向量，绘制粒子，坐标减去向量保持坐标不变</strong>等一系列通法<br>最终的效果就是这样啦<br><img src="https://upload-images.jianshu.io/upload_images/8109631-f1492c926c67a7e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="绕Y轴旋转"></p><hr><p>那么我们如果想制作一个类似物品掉落时，然后物品围绕Y轴旋转的那种效果，我们又要怎么做呢？这里我们就要利用到Yaw和Pitch</p><p>首先我们这里新建一个类用于旋转圆特效的实现，并且让它继承BukkitRunnable，当然Runnable也是可以的</p><pre><code>public class RotatableCircle extends BukkitRunnable {    // 原点    private Location location;    // X轴上的单位向量    private Vector originalVector;    private float yaw = 0;    private double radius = 1D;    public RotatableCircle(Location location) {        this.location = location.clone();        // getVector() 方法是上面已经发过的一个方法，目的是构造一个向量OA        originalVector = getVector(location, location.clone().add(1, 0, 0));    }    @Override    public void run() {    }    /**     * 取第一个坐标到第二个坐标的向量     *     * @param firstLocation  坐标1     * @param secondLocation 坐标2     * @return {@link Vector}     */    public static Vector getVector(Location firstLocation, Location secondLocation) {        return secondLocation.clone().subtract(firstLocation).toVector();    }}</code></pre><p>从上方的代码我们先简单的需要几个基本量，<strong>待旋转向量和原点</strong>即可，之后yaw和radius分别是yaw和圆的半径</p><p><strong>在构造函数里，我们将传入的location参数进行克隆以防原location的变动</strong><br>之后我们依然<strong>做一个向量OA，当作待旋转向量</strong></p><p>之后我们进行几何分析，看下图<br><img src="https://upload-images.jianshu.io/upload_images/8109631-370b6d67e0caf43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="向量OA"></p><p>首先这是一个向量OA，如果我们想让它旋转1个yaw单位可以使用以下方法<br><code>Vector vector = VectorUtils.rotateVector(originalVector, 1, 0)</code><br><img src="https://upload-images.jianshu.io/upload_images/8109631-0e200fe6aa94c495.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="旋转θ个yaw角"><br>那么这就是旋转一个θ yaw角，那么pitch角要怎么旋转呢？<br><img src="https://upload-images.jianshu.io/upload_images/8109631-fc7c340b7847a6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="旋转θ个pitch角"><br>根据上方的图我们将向量OA旋转θ个角之后得到了向量OB，那么我们就可以这么写我们的代码</p><pre><code>// 请注意第三个参数 θ 是角度Vector vector = VectorUtils.rotateVector(originalVector, 0, θ)</code></pre><p>那么有了上面的铺垫我们可以这么写我们的RotatableCircle</p><pre><code>public class RotatableCircle extends BukkitRunnable {    // 原点    private Location location;    // X轴上的单位向量    private Vector originalVector;    private float yaw = 0;    private double radius = 1D;    public RotatableCircle(Location location) {        this.location = location.clone();        originalVector = VectorUtils.getVector(location, location.clone().add(1, 0, 0));    }    @Override    public void run() {        // 我们假设是第一次yaw旋转, 那么是0, 所以我们先将originalVector旋转yaw个单位        Vector vectorYaw = VectorUtils.rotateVector(originalVector, yaw, 0);        // 之后我们将pitch进行 90 ~ -90 的一个循环用于将向量进行上下翻转        for (float pitch = 90; pitch &gt; -90; pitch--) {            Vector vector = VectorUtils.rotateVector(vectorYaw, 0, pitch);            // 这样得出来的vector只有一个半圆, 那么另外一个向量我们可以通过得到相反向量来制造出            Vector reverseVector = vector.clone().multiply(-1);            // 在正方向上绘制粒子            location.add(vector);            location.getWorld().spawnParticle(Particle.FLAME, location, 0);            location.subtract(vector);            // 在反方向上绘制粒子            location.add(reverseVector);            location.getWorld().spawnParticle(Particle.FLAME, location, 0);            location.subtract(reverseVector);        }        // 将yaw设定在0~360之间进行循环        if (yaw &gt;= 360) {            yaw = 0;        } else {            yaw++;        }    }}</code></pre><p>我们在代码中像下方一样调用</p><pre><code>RotatableCircle rotatableCircle = new RotatableCircle(location);rotatableCircle.runTaskTimer(你插件的主类实例, 0L, 3L);</code></pre><p><strong>最终的效果</strong><br><img src="https://upload-images.jianshu.io/upload_images/8109631-59e4a6143a87f196.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="最终效果"></p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
      <tag>数学</tag>
      
      <tag>MC特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的MC特效(二 | 向量基础)</title>
    <link href="/2018/12/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%BA%8C)/"/>
    <url>/2018/12/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h4><ul><li>导读</li><li>数学上的向量与BukkitAPI中的向量</li><li>利用向量进行画线操作</li><li>利用画线进行多边形的绘制</li><li>一个五角星</li></ul><hr><h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4><p>本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)<br>本教程使用的 Spigot1.10.2-R0.1-SNAPSHOT 核心<br>在阅读之前请确保你具有高中数学必修4和Java基础的知识<br>(没有我也会适当的解释的)</p><p>&lt;To初中生&gt;: 如果你是初中的话，别慌，你有趋向的概念就可以读懂本教程(应该吧…)<br>&lt;To高中生&gt;: 如果你还未学到关于上面的那本书，别慌学到了再来看也行233 (雾<br>&lt;To大学生&gt;: 没什么好说的…</p><hr><h4 id="1-数学上的向量与BukkitAPI中的向量"><a href="#1-数学上的向量与BukkitAPI中的向量" class="headerlink" title="1.数学上的向量与BukkitAPI中的向量"></a>1.数学上的向量与BukkitAPI中的向量</h4><p><strong>此处只讲平面向量</strong></p><p>在教程开始之前我们来谈一下数学上对向量的定义<br>*<em>定义:<br>*</em><br>向量由长度和方向组成，总是用来描述从一个点到另一个的移动。<br>和我们平常所说的数量不同的是，向量则是有了方向这一概念<br>那么我们利用图来理解一下向量</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-f9171d288c45fa74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图 1-1"></p><p>在 图 1-1 当中我们定义两个点一个是<strong>点A</strong>一个是<strong>点B</strong>，那么我们<strong>以A为起点，B为终点作一条有向线段</strong>，得到下图<br><img src="http://upload-images.jianshu.io/upload_images/8109631-b4f38fb09033b50d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图 1-2"></p><p>在 图1-2 当中我们作了一条<strong>有向线段</strong>，而这条有向线段我们称之为<strong>向量AB</strong>，那么这就是向量的一个基本定义</p><p><strong>向量的坐标表示: 假设A = (1, 3), B = (2, 4)，则向量AB = (2 - 1, 4 - 3)，即终点减起点<br>(在BukkitAPI中，向量以坐标来表示所以突出这一段)</strong></p><p>我们再来谈谈关于向量的一些相关概念<br><strong>向量的模:</strong> 若我们有一个向量AB，那么它的模可以使用 <strong>|AB|</strong> 来进行表示，表示的则是<strong>AB之间的距离，即向量AB的长度</strong><br><strong>单位向量:</strong> 我们把一个模等于1个单位长度的向量叫做单位向量<br><strong>相反向量:</strong> 与<strong>向量A</strong>长度相等，方向相反的向量，叫做向量<strong>A的相反向量</strong><br><strong>零向量:</strong> 我们把<strong>模长等于0</strong>的向量叫做零向量</p><hr><h4 id="向量的基本运算"><a href="#向量的基本运算" class="headerlink" title="向量的基本运算"></a>向量的基本运算</h4><p>向量是有加和乘的，那么我们根据以下的一些图来了解一下它们的基本运算，<br><img src="http://upload-images.jianshu.io/upload_images/8109631-aebba809ea979a09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"><br><strong>向量相加应满足平行四边形定则或三角形定则<br>若向量A = (1, 3), 向量B = (2, 4)，则向量A+向量B = (3, 7)</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-239da7f92cda0b66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p><strong>在上方我们给一个向量乘以-1，得到了反方向的向量，这个我们称之为相反向量<br>若向量A = (1, 3),向量A * 2 = (2, 4)<br>若向量A = (1, 3),向量A * -1 = (-1, -3)</strong></p><hr><h4 id="BukkitAPI上的向量-——-Vector"><a href="#BukkitAPI上的向量-——-Vector" class="headerlink" title="BukkitAPI上的向量 —— Vector"></a>BukkitAPI上的向量 —— Vector</h4><p>那么BukkitAPI上对向量的定义又是怎么样的呢？首先我们在 <strong>org.bukkit.util</strong> 包下找到一个叫<a href="https://docs.windit.net/Chinese_BukkitAPI/org/bukkit/util/Vector.html" target="_blank" rel="noopener">Vector</a>的类</p><p><strong>那么在BukkitAPI上，Vector类用于表示从一个Location到另一个Location的”趋势”。</strong></p><p>若我们想获取从LocationA到LocationB的向量，我们可以使用以下的代码，即<strong>终点减起点</strong></p><pre><code>/** * 取第一个坐标到第二个坐标的向量 * * @param firstLocation  坐标1 * @param secondLocation 坐标2 * @return {@link Vector} */public static Vector getVector(Location firstLocation, Location secondLocation) {    return secondLocation.subtract(firstLocation).toVector();}</code></pre><p><strong>请注意！这里的 secondLocation.subtract() 将会改变secondLocation的值</strong></p><h4 id="2-利用向量进行画线操作"><a href="#2-利用向量进行画线操作" class="headerlink" title="2.利用向量进行画线操作"></a>2.利用向量进行画线操作</h4><p>首先我们来看张图</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-fe75e046e164e74f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图 2-1"><br>图 2-1</p><p>在上方的图中，我们定义两个点，一个是A一个是B，那么对应到MC中它们就是两个Location，LocationA和LocationB，那么我们要怎么使用向量来给这两个点进行画线的操作呢？</p><p>思路：</p><ul><li>首先我们要获取一下这两个点的一个向量，我们称之为向量AB</li><li>之后我们把向量AB转为单位向量，方向不变</li><li>在Vector类里有个叫multiply的函数，这个函数是对Vector进行乘的操作</li><li>若向量AB乘以2，那么它的长度就会乘以了2，之后我们再使用locationA的add函数进行增加Vector，这样我们就可以获得在AB上期中的一个点了，然后我们进行遍历的操作以此类推…（看不懂的话喝杯茶…）</li></ul><p>我们把上方的思路转为几何来理解一下<br><img src="http://upload-images.jianshu.io/upload_images/8109631-66c189ab14d15704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"><br>有了上面的思路，我们就可以打代码了</p><p>首先我们要获取它们向量，这里我调用了<strong>location的clone函数</strong>，因此不会改变locB的值<br><code>Vector vectorAB = locB.clone().subtract(locA).toVector();</code><br>之后我们先获取一下该向量的长度，等下要用<br><code>double vectorLength = vectorAB.length();</code><br>然后我们再把该向量转为单位向量<br><code>vectorAB.normalize();</code><br>然后我们就需要利用for循环<strong>来计算出一个每一个需要multiply的值</strong></p><pre><code>for (double i = 0; i &lt; vectorLength; i += 0.1) {     // 这里如果我们直接进行multiply的话则会修改vectorAB的值，所以我们先clone再multiply     Vector vector = vectorAB.clone().multiply(i);}</code></pre><p><strong>i的类型:</strong></p><ul><li>首先我们来解释为什么这里的i的类型为double</li><li>因为在坐标运算中，精确度是比较高的，当两个点相近时可能他们的值还没有到1，可能只有0.8左右的长度，所以我们使用double来修饰</li></ul><p><strong>结束值:</strong> 之后我们来谈谈这里为什么要循环到向量的模长的时候就结束，在上面的思路我们只举了当i == 2时的一个情况，而我们想获得这两个点之间的点，所以我们要填入向量的模长</p><p><strong>步长:</strong> 这里我们依然修改了循环的步长，那么它的作用是什么？其实就是在设定每一个add出来后的点的<strong>间距</strong> （这里我不懂怎么解释，直接画了个图给你们，按照图来理解会很好哦~）<br><img src="http://upload-images.jianshu.io/upload_images/8109631-03035b9b0cddc4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"><br>那么我就会得到每一次从点A往点B进行逐步偏移的一个效果，然后我们每次给locA，进行add的操作就可以得到当前循环应该得到的Location</p><pre><code>locA.add(vector);locA.getWorld().playEffect(locA, Effect.HAPPY_VILLAGER, 1); // 这里是播放粒子的代码...locA.subtract(vector);</code></pre><p><strong>完整代码:</strong></p><pre><code>public static void buildLine(Location locA, Location locB) {    Vector vectorAB = locB.clone().subtract(locA).toVector();    double vectorLength = vectorAB.length();    vectorAB.normalize();    for (double i = 0; i &lt; vectorLength; i += 0.1) {        Vector vector = vectorAB.clone().multiply(i);        locA.add(vector);        locA.getWorld().playEffect(locA, Effect.HAPPY_VILLAGER, 1);        locA.subtract(vector);    }}</code></pre><p>游戏内的效果:<br><img src="http://upload-images.jianshu.io/upload_images/8109631-c32ef6631b2344a8.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="image"></p><blockquote><p><strong>注: 以下的内容则是对于画线的一些实践，跟上方的理论知识有部分的联系，所以可看可不看，不属于应掌握内容</strong></p></blockquote><h4 id="3-利用画线进行多边形的绘制"><a href="#3-利用画线进行多边形的绘制" class="headerlink" title="3.利用画线进行多边形的绘制"></a>3.利用画线进行多边形的绘制</h4><p>在第一章的时候，我们利用三角函数画出了一个圆，如果我们向画的是一个多边形该怎么做呢？</p><p>这里顺便讲个小故事，在很久以前有个人叫<strong>阿基米德</strong>，他使用了一种叫做<strong>割圆法</strong>的方式计算出了圆周率，那么这个<strong>割圆法的步骤</strong>可以<a href="https://www.bilibili.com/video/av25406675" target="_blank" rel="noopener">看这个视频</a>来了解一下</p><p>那么我们提到这个割圆法有什么用呢，首先这个割圆法利用的是<strong>内接六边形</strong>，再使用<strong>勾股定理</strong>求出来的，之后再<strong>内接八边形，十六边形</strong>一直下去…那么我们多边形始终都离不开一个圆，当然了是内接的多边形，而且还是<strong>规则的多边形</strong>，那么如果我们要画一个五边形或者三角形该怎么画呢？</p><p>首先既然是多边形，就会有点，我们找到点之后就成功了一半，我们来看一张图<br><img src="http://upload-images.jianshu.io/upload_images/8109631-7ec23efd4f399402.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图 3-1"></p><p>在上图中我们找到了五个点，这五个点，每两两之间的夹角都为72°，这72°是怎么来的呢？我们利用<strong>360° / 5就可以得到72°，那么从360°/5得到的是一个单位圆中平均分成五块，且每块跟X轴正半轴的夹角都为72的倍数</strong>，那么这五个点就是这么找出来的</p><p>我们把它放入代码中看看要怎么操作<br>我们依然使用玩家的location作为原点O，之后我们实例化一个List用于保存这五个点</p><pre><code>Location playerLocation = player.getLocation();List&lt;Location&gt; locations = Lists.newArrayList();</code></pre><p>因为我们只是需要72的倍数的角度，所以我们把步长修改为 i += 72 (等价于 i = i + 72)</p><pre><code>for (int i = 0; i &lt; 360; i += 72) {    // 转弧度制    double radians = Math.toRadians(i);    locations.add(playerLocation.clone().add(3 *     Math.cos(radians), 0D, 3 * Math.sin(radians)));}</code></pre><p>为了以便于观看我将每次cos和sin计算的值都乘以3来扩大点到原点的距离<br>之后我们的locations里就存放有那5个点了<br>如果我们现在对这五个点播放粒子的话你可以看到以下这样的图<br><img src="http://upload-images.jianshu.io/upload_images/8109631-e8916358317f7123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"><br>那么我们剩下的就是每个点依次顺序进行画线操作，然后你就可以看到以下的效果了<br><img src="http://upload-images.jianshu.io/upload_images/8109631-c9268d1984e316c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><h4 id="4-一个五角星"><a href="#4-一个五角星" class="headerlink" title="4.一个五角星"></a>4.一个五角星</h4><p>其实也没什么好说的…看代码吧…</p><pre><code>Location playerLocation = player.getLocation();List&lt;Location&gt; locations = Lists.newArrayList();for (int i = 0; i &lt; 360; i += 72) {    // 转弧度制    double radians = Math.toRadians(i);    locations.add(playerLocation.clone().add(3 * Math.cos(radians), 0D, 3 * Math.sin(radians)));}buildLine(locations.get(0), locations.get(2));buildLine(locations.get(0), locations.get(3));buildLine(locations.get(1), locations.get(3));buildLine(locations.get(1), locations.get(4));buildLine(locations.get(2), locations.get(4));</code></pre><p><strong>备注: 这里的buildLine是上方我所发出来的一个方法哦</strong></p><p>上方的locations的画线操作我们可以利用图来理解一下就可以</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-6bebbbb151b102c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p>为了方便解释我给每个点都起了名字括号内的是它在locations中的下标</p><p>如果我们要画一个五角星，可以这么画<br>连接AC, AD，即0 -&gt; 2，0 -&gt; 3<br>连接BD, BE，即1 -&gt; 3，1 -&gt; 4<br>连接CE，即 2 -&gt; 4<br>然后你就可以看到这样的五角星了<br><img src="http://upload-images.jianshu.io/upload_images/8109631-eccd92b040cd93db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
      <tag>数学</tag>
      
      <tag>MC特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的MC特效(一 | 在X, Z轴上的画圆操作)</title>
    <link href="/2018/05/20/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%B8%80)/"/>
    <url>/2018/05/20/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MC%E7%89%B9%E6%95%88(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h3><ul><li>导读</li><li>数学与Minecraft的融合</li><li>利用数学在Minecraft中画一个圆</li><li>利用数学在Minecraft中画一个球</li></ul><hr><h5 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h5><p>本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)<br>本教程使用的 Spigot1.10.2-R0.1-SNAPSHOT 核心<br>在阅读之前请确保你具有高中数学必修4和Java基础的知识<br>(没有我也会适当的解释的)</p><p>&lt;初中生&gt;: 如果你是初中的话，别慌，你有函数的概念就可以读懂本教程(应该吧…)<br>&lt;高中生&gt;: 如果你还未学到关于上面的两本书，别慌学到了再来看也行233 (雾</p><hr><h5 id="数学与Minecraft的融合"><a href="#数学与Minecraft的融合" class="headerlink" title="数学与Minecraft的融合"></a>数学与Minecraft的融合</h5><p>首先我们都知道Minecraft是一个3D游戏，所以它就有了XYZ这三个轴，那么我们可以看如下的一张图来了解一下</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-2d19dbfb979d9c1c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p><strong>本教程暂不涉及关于Y轴的相关内容，所以我们可以先从平面直角坐标系来分析</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://upload-images.jianshu.io/upload_images/8109631-bdac487be24902d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></h2><h5 id="利用数学在Minecraft中画一个圆"><a href="#利用数学在Minecraft中画一个圆" class="headerlink" title="利用数学在Minecraft中画一个圆"></a>利用数学在Minecraft中画一个圆</h5><p><strong>以下内容需要sin函数与cos函数的相关知识！</strong><br>首先呢我们先来看一张图（自己用word画的2333）<br><img src="http://upload-images.jianshu.io/upload_images/8109631-0332f34619e797e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p><strong>分析:</strong><br>     首先这个坐标系有一个<strong>单位圆</strong>(半径为1的圆)，然后我们看到<strong>角α为30°</strong>，之后<strong>点P的横坐标为 √3/2 纵坐标为 1/2</strong></p><p>然后我们再看下图</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-17c456f2fb78ae8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p>那么我们是否可以这么认为，点P的横坐标其实是 cos(30°) 而纵坐标就是 sin(30°)呢？</p><blockquote><p>补充: 如果你已经有了参数方程的概念那么，这里你可以忽略了 —— 2019/1/12</p></blockquote><blockquote><p>PI 代表圆周率π, 之后π = 180° (别问我为什么，课堂上自己学去233)*</p></blockquote><p><strong>P(cos(30°), sin(30°))， 弧度制: P(cos(PI/6), sin(PI/6))</strong></p><p>那么P的横坐标和纵坐标都是可以利用函数 cos和sin 求出，那么我们为什么不可以<strong>遍历一下把360°全部都给算出</strong>呢？所以我看写出下方的代码这样我们就可以把一周角里所有的角度都给遍历了一便，并且我们都算出了<strong>每个角度所对应的cos值和sin值</strong>吧，然后我们需要把他们作用到Minecraft当中</p><pre><code>// 我们把玩家脚下的location作为是原点O Location location = player.getLocation(); for (int degree = 0; degree &lt; 360; degree++) {    double radians = Math.toRadians(degree);    double x = Math.cos(radians);    double y = Math.sin(radians);}</code></pre><p>那么在上图的for循环语句块中我们有两个变量 x y，也就是 <strong>P(x, y)</strong> 吧，之后我们回头看一下for循环语句块外的那个<strong>变量location</strong>，那个我们可以理解成是在上图中的<strong>原点O</strong>，那么我们做个假设，我们需要把点P转换成MC中的Location要怎么做？，其实很简单</p><pre><code>location.add(x, 0, y);</code></pre><p>我们把location的X轴假想为0, Z轴假想为0（这里的X轴和Z轴指的是Minecraft中的那两个轴）即<strong>图中原点O为(0, 0)</strong>，那么<strong>在Minecraft中不可能任何时候原点的X Z轴都是0</strong>，所以我们需要做相加的操作</p><p>（上面可能会听得一头雾水，简单来说当<strong>原点O不为(0, 0)时</strong>，假设为(2, 2)，那么我们要做的是给<strong>玩家的周围建立圆</strong>吧，那么这时候点P的坐标应该为 <strong>P(2 + x, 2 + y)）</strong></p><blockquote><p>要是还听不懂的话那就去喝杯茶，洗个澡吧2333</p></blockquote><p>那么我们可以做以下的操作了</p><pre><code>location.add(x, 0D, y);// 播放粒子location.getWorld.playEffect(location, Effect.HAPPY_VILLAGER, 1);// 为什么要减？因为我们要确保原点是不变的状态才可以哦~location.subtract(x, 0D, y);</code></pre><p>游戏内效果<br><img src="http://upload-images.jianshu.io/upload_images/8109631-512ddf977900c346.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="游戏内的效果"></p><p>完整代码</p><pre><code>// 我们把玩家脚下的location作为是原点OLocation location = player.getLocation();for (int degree = 0; degree &lt; 360; degree++) {    double radians = Math.toRadians(degree);    double x = Math.cos(radians);    double y = Math.sin(radians);    location.add(x, 0, y);    location.getWorld().playEffect(location, Effect.HAPPY_VILLAGER, 1);    location.subtract(x, 0, y);}</code></pre><h5 id="利用数学在Minecraft中画一个球"><a href="#利用数学在Minecraft中画一个球" class="headerlink" title="利用数学在Minecraft中画一个球"></a>利用数学在Minecraft中画一个球</h5><p>首先我们来观察一下sin的<strong>函数图像</strong>，具体如下</p><p><img src="https://upload-images.jianshu.io/upload_images/8109631-c004142745f40231.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图 2-1"></p><p>从上图可以看出 sin函数 始终在 1~-1 之间徘徊，所以我们认为它是有<strong>周期性</strong>的，那么这跟球的生成有什么联系呢？我们看下图</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-0a5961213221bee9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图 2-2"></p><p>首先这是一个球对吧，然后呢我在球上画了几个<strong>横截面(</strong>才不是什么旋风<strong>)</strong>出来，那么通过上图我们是不是可以得出一个结论，一个球体其实是由<strong>无数个圆</strong>构成的？只是<strong>它们的半径不同</strong>对吧。那这跟sin函数有啥联系呢？</p><p>首先我们回到sin的函数图像，我们看<strong>当x在0~π之间时</strong>连起来的y轴是不是像一个半圆啊？而且它们的<strong>半径(这里的半径可以理解为sin函数中的y轴)</strong>也是不同的，那么我们是不是可以这么认为，我们只需要 <strong>0 ~ **</strong>π** 之间的x值，然后代入函数当中就可以求出对应的y轴的值了？</p><p>那么 <strong>0 ~ π</strong> 是什么值呢？其实在上面的圆中我就讲过 <strong>π=180°，</strong>所以我们求得其实就是 <strong>sin(0 ~ 180°)。</strong></p><p>那么有了上面的思路我们可以<strong>求出每个圆的半径</strong>对吧，那么我们写出下面的代码</p><pre><code>for (double i = 0; i &lt; 180; i++) {    double radians = Math.toRadians(i);         double radius = Math.sin(radians);}</code></pre><p>在上方的代码当中我们求出了一个球中每个圆的半径, 但是我们还需要考虑一件事，我们是不是要规定一下每个圆之间的距离啊？</p><p>那么我们引入<strong>cos</strong>的函数图像<br><img src="https://upload-images.jianshu.io/upload_images/8109631-1c1ac82cccdbfd35.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图 2-3"></p><p>从上图可以看出 f(x) = cos(x),<br>当<strong>x=0</strong>时, f(x)则为1.<br>当<strong>x=π</strong>时，f(x)则为-1.</p><p>那么我跟sin的函数图像联系一下, 在上面的代码中我们发现，radius的值是从小到大再到小，那么我们想一下，如果半径是小的那么那个圆是也是小的，而我们要画的圆是<strong>从上往下</strong>画的（观察图 2-2）对吧，所以我们是不是要给那个<strong>最小的圆的y轴是最高的</strong>？（没看懂？喝杯茶吧）而<strong>cos函数</strong>就可以帮我们达到这一点，所以我们写出以下的代码</p><p><code>double y = Math.cos(radians);</code><br>那么这样我们就可以获得<strong>当前for循环时</strong>那个圆的高度了。</p><p>在上面的结构中我们得到了当前圆的<strong>半径和高度</strong>，那么我们要怎么通过这两个东西画出来呢？</p><p>我们在第三章画圆时曾经做过这么一个操作</p><pre><code>for (int degree = 0; degree &lt; 360; degree++) {    double radians = Math.toRadians(degree);        double x = Math.cos(radians);         double y = Math.sin(radians);}</code></pre><p>上方的代码中我们只能制造出一个<strong>半径为1</strong>的圆，那么我们想扩大它的半径需要怎么做？</p><p>我们这里又引入一个函数<strong>y=Asin(ωx + φ)</strong> <em>(这里的sin也可以为cos)</em>，其实这个函数跟sin函数差不多只不过多了几个变量，那么这里我们只需要考虑A的值，</p><p>为什么呢？我们来看一下这个函数在数学上的定义：</p><ul><li><em>φ（初相位）：决定波形与X轴位置关系或横向移动距离（左加右减）</em></li><li><em>ω：决定周期（最小正周期T=2π/|ω|）</em></li><li><strong>A：决定峰值（即纵向拉伸压缩的倍数）</strong></li></ul><p><strong>由于这里我们只考虑A所以我们可以把上方的函数简写为 y = Asin(x)，假设我们的A为2，那就是sin(x) * 2了，那么反应在函数图像上是这样的</strong></p><p><strong><img src="http://upload-images.jianshu.io/upload_images/8109631-d8fa9a9d746e0d0c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></strong> </p><p>那么有了上面的概念<strong>我们不妨使用 Math.cos(x) * 半径 来扩大本次循环时所对应的半径</strong>，所以我们写出以下的代码</p><pre><code>for (double j = 0; j &lt; 360; j ++) {    // 依然需要做角度转弧度的操作     double radiansCircle = Math.*toRadians*(j);         double x = Math.*cos*(radiansCircle) * radius;         double z = Math.*sin*(radiansCircle) * radius;}</code></pre><p>那么这样就可以控制好本次循环我们需要这个圆多少半径了，那么我们写好之后就可以放在Minecraft中看看效果</p><p>完整代码:</p><pre><code>for (double i = 0; i &lt; 180; i++) {    // 依然要做角度与弧度的转换    double radians = Math.toRadians(i);    // 计算出来的半径    double radius = Math.sin(radians);    double y = Math.cos(radians);    for (double j = 0; j &lt; 360; j++) {        // 依然需要做角度转弧度的操作        double radiansCircle = Math.toRadians(j);        double x = Math.cos(radiansCircle) * radius;        double z = Math.sin(radiansCircle) * radius;        location.add(x, y, z);        location.getWorld().playEffect(location, Effect.HAPPY_VILLAGER, 1);        location.subtract(x, y, z);    }}</code></pre><p>游戏内的效果<br><img src="http://upload-images.jianshu.io/upload_images/8109631-78b42b28cadfa8ba.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="效果"></p><p>然后你就会发现你的游戏卡得一匹2333，因为我们是在360°全方位的进行渲染粒子的操作2333，但实际业务中我们可能并不需要做这种需求，那么我们就需要做一个关于跳跃的操作呗，我们看下面的代码</p><pre><code>for (double i = 0; i &lt; 180; i += 180 / 6) {    // 依然要做角度与弧度的转换    double radians = Math.toRadians(i);    // 计算出来的半径    double radius = Math.sin(radians);    double y = Math.cos(radians);    for (double j = 0; j &lt; 360; j += 180 / 6) {        // 依然需要做角度转弧度的操作        double radiansCircle = Math.toRadians(j);        double x = Math.cos(radiansCircle) * radius;        double z = Math.sin(radiansCircle) * radius;        location.add(x, y, z);        location.getWorld().playEffect(location, Effect.HAPPY_VILLAGER, 1);        location.subtract(x, y, z);    }}</code></pre><p>跟上面的代码不同的是我在遍历的时候修改了<strong>步长(step)</strong>，那这一个有什么讲究呢？我们在每一次循环给 i 和 j就加的是<strong>30</strong>了对吧，而不是自加1，</p><p>那么我们看<strong>第一层循环</strong>，这一层循环控制的步长其实是我们其实需要多少圈，为什么呢？我们看下面的图来理解一下</p><p><img src="http://upload-images.jianshu.io/upload_images/8109631-c5aa3f61a470cab2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p>这里我为了方便读者理解我把图 2-1 旋转了一下，上图我们假想黑点是玩家的location，那么那几个红点就是我们把<strong>步长</strong>修改后所得到的产物</p><p>那么第二层循环我修改的步长又是什么意思呢？我们也拿张图来理解一下<img src="http://upload-images.jianshu.io/upload_images/8109631-0163144e4c0e42f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p>上图中每个角的度数都是30°，那么我修改了步长之后是不是我只会在这几个黑点上面做playEffect()的操作了？（看不懂的话喝口水再来看233）</p><p>修改了步长后游戏内的效果:<br><img src="http://upload-images.jianshu.io/upload_images/8109631-46416920308dc784.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="image"></p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>内容依然是挺少的。。希望能教给读者一些东西吧233 </p>]]></content>
    
    
    <categories>
      
      <category>Bukkit教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bukkit</tag>
      
      <tag>Minecraft</tag>
      
      <tag>Java</tag>
      
      <tag>数学</tag>
      
      <tag>MC特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
